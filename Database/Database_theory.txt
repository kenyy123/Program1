

http://blog.csdn.net/mengxiangfeiyang/article/details/7841653


ORACLE体系结构，很详细
http://blog.csdn.net/sinat_33363493/article/details/51782609

Oracle启动过程
http://www.cnblogs.com/penho/p/5013371.html


Oracle SQL Performance
http://www.cnblogs.com/rootq/archive/2008/11/17/1334727.html





Oracle 体系结构

 Oracle数据库有物理结构和逻辑结构。数据库的物理结构是数据库中的操作系统文件的集合。
 
 数据库的物理结构由数据文件、控制文件和重做日志文件组成。

 从逻辑角度来看，oracle数据库至少包含一个表空间，表空间至少包含一个段，段由区做成，区有块组成。需要注意的是表空间可以包含若干个数据文件，段可以跨同一个表空间的多个数据文件，区只能在同一个数据文件内。

 oracle数据库是一个被统一处理的的数据的集合，从物理角度来看包括三类文件数据文件，控制文件，重做日志文件。从逻辑角度来看，oracle数据库至少包含一个表空间，表空间至少包含一个段，段由区做成，区有块组成。需要注意的是表空间可以包含若干个数据文件，段可以跨同一个表空间的多个数据文件，区只能在同一个数据文件内。

 Oracle系统体系结构由三部分组成：逻辑结构、物理结构和实例。

  数据文件：数据文件是数据的存储仓库。

  联机重做日志文件：联机重做日志文件包含对数据库所做的更改记录，在发生故障时能够恢复数据。重做日志按时间顺序存储应用于数据库的一连串的变更向量。其中仅包含重建（重做）所有已完成工作的最少限度信息。如果数据文件受损，则可以将这些变更向量应用于数据文件备份来重做工作，将它恢复到发生故障的那一刻前的状态。重做日志文件包含联机重做日志文件（对于连续的数据库操作时必须的）和归档日志文件（对于数据库操作是可选的，但对于时间点恢复是必须的）。
查看系统的redo log的信息
SQL> select group#,sequence#,bytes,members,status from v$log;

    GROUP#  SEQUENCE#      BYTES    MEMBERS STATUS
---------- ---------- ---------- ---------- ----------------
         1         22   52428800          1 INACTIVE
         2         23   52428800          1 CURRENT
         3         21   52428800          1 INACTIVE
SQL> select member from v$logfile;
MEMBER
/u01/app/oracle/oradata/hnzk/redo03.log
/u01/app/oracle/oradata/hnzk/redo02.log
/u01/app/oracle/oradata/hnzk/redo01.log

 控制文件：控制文件包含维护和验证数据库完整性的必要的信息。控制文件虽小，但作用非常大。它包含指向数据库其余部分的指针：联机重做日志文件和数据文件的位置，以及更新的归档日志文件的位置。它还存储着维护数据库完整性所需的信息。控制文件不过数MB，却起着至关重要的作用。

除了三个必须的文件外数据库还能有其它非必须的文件如：参数文件、口令文件及归档日志文件。

实例参数文件：当启动oracle实例时，SGA结构会根据此参数文件的设置内置到内存，后台进程会据此启动。

口令文件：用户通过提交用户名和口令来建立会话。Oracle根据存储在数据字典的用户定义对用户名和口令进行验证。

归档重做日志文件：当重做日志文件满时将重做日志文件进行归档以便还原数据文件备份。



 实例由内存和后台进程组成，它暂时存在于RAM和CPU中。当关闭运行的实例时，实例将随即消失。数据库由磁盘上的物理文件组成，不管在运行状态还是停止状态，这些文件就一直存在。因此，实例的生命周期就是其在内存中存在的时间，可以启动和停止。一旦创建数据库，数据库将永久存在。通俗的讲数据库就相当于平时安装某个程序所生成的安装目录，而实例就是运行某个程序时所需要的进程及消耗的内存。

Oracle的内存架构包含两部分系统全局区（SGA）和程序全局区（PGA）。 

Oracle的内存架构包含两部分系统全局区（SGA）和程序全局区（PGA）。 



 3.1程序全局区

3.2系统全局区

在操作系统提供的共享内存段实现的内存结构称为系统全局区（SGA）。SGA在实例启动时分配，在关闭时释放。在一定范围内，可以在实例运行时通过自动方式或响应DBA的指令，重新调整11g实例中的SGA及其中的组件的大小。

由上图可知SGA至少包含三种数据结构：数据库缓冲区缓存、日志缓冲区及共享池。还可能包括：大池、JAVA池。可以使用show sga，查看sga的状态。

3.1.1共享池
   共享池由许多子结构组成，这些子结构由oracle服务器内部自动管理。在共享池的总体大小范围内，各个结构的大小将因针对实例的活动模式而异。共享池本身的大小可以动态重调。
    a.库缓存是内存区域，按其已分析的格式存储最近执行的代码。分析就是将编程人员编写的代码转换为可执行的代码，这是oracle根据需要执行的一个过程。通过将代码缓存在共享池，可以在不重新分析的情况下重用，极大地提高性能。
    b.数据字典缓存有时称为“行缓存”，它存储最近使用的对象定义：表、索引、用户和其他元数据定义的描述。通过将此类定义放在SGA的内存中，以便使所有会话可以直接访问它们，而不是被迫从磁盘上的数据字典中重复读取它们，从而提高分析性能。
    c.PL/SQL区：存储的PL/SQL对象是过程、函数、打包的过程、打包的函数、对象类型定义和触发器。它们全都像源代码那样存储在数据字典中，也使用已编译的格式。当会话调用存储的PL/SQL对象时，它必须从数据字典读取。为了避免重复读取，将对象缓存到共享池的PL/SQL区。
  共享池的大小对性能产生重要影响，它应该足够大，以便缓存所有频繁执行的代码和频繁访问的对象定义，但也不能过大，以至于连仅执行一次的语句也要缓存。如果共享池过小，则性能下降，因为服务器会话将反复抢夺其中的空间来分析语句，此后，这些语句会被其他语句重写，在重新执行时，将不得不再次分析。过大的共享池也会对性能产生不良影响，因为搜索需要的时间过长。如果共享池小于最优容量，则性能将下降。但有一个最小容量，如果低于此限度，则语句将失败。确定最优容量是一个性能调整问题，大多数数据库都需要一个数百MB的共享池。有些应用程序需要1GB以上的共享池，但很少有应用程序能够在共享池小于100 MB时充分运行。
       共享池在实例启动时分配。从9i开始，可以随时将其调大或调小。可以采用手动方式重调，也可以根据工作负荷自动调整大小。
手动调整共享池的大小：
select COMPONENT,CURRENT_SIZE,MIN_SIZE,MAX_SIZE from v$sga_dynamic_components;//显示可以动态重设大小的SGA组件的当前、最大和最小容量
SQL> select COMPONENT,CURRENT_SIZE,MIN_SIZE,MAX_SIZE from v$sga_dynamic_components;

COMPONENT                                                        CURRENT_SIZE   MIN_SIZE   MAX_SIZE
---------------------------------------------------------------- ------------ ---------- ----------
shared pool                                                         104857600  100663296          0
large pool                                                            4194304    4194304          0
java pool                                                             4194304    4194304          0
streams pool                                                                0          0          0
DEFAULT buffer cache                                                167772160  167772160          0
KEEP buffer cache                                                           0          0          0
RECYCLE buffer cache                                                        0          0          0
DEFAULT 2K buffer cache                                                     0          0          0
DEFAULT 4K buffer cache                                                     0          0          0
DEFAULT 8K buffer cache                                                     0          0          0
DEFAULT 16K buffer cache                                                    0          0          0
DEFAULT 32K buffer cache                                                    0          0          0
ASM Buffer Cache                                                            0          0          0

13 rows selected.

SQL> ALTER SYSTEM SET SHARED_POOL_SIZE = 110M;

System altered.

SQL> select COMPONENT,CURRENT_SIZE,MIN_SIZE,MAX_SIZE from v$sga_dynamic_components;

COMPONENT                                                        CURRENT_SIZE   MIN_SIZE   MAX_SIZE
---------------------------------------------------------------- ------------ ---------- ----------
shared pool                                                         117440512  100663296          0
large pool                                                            4194304    4194304          0
java pool                                                             4194304    4194304          0
streams pool                                                                0          0          0
DEFAULT buffer cache                                                155189248  155189248          0
KEEP buffer cache                                                           0          0          0
RECYCLE buffer cache                                                        0          0          0
DEFAULT 2K buffer cache                                                     0          0          0
DEFAULT 4K buffer cache                                                     0          0          0
DEFAULT 8K buffer cache                                                     0          0          0
DEFAULT 16K buffer cache                                                    0          0          0
DEFAULT 32K buffer cache                                                    0          0          0
ASM Buffer Cache                                                            0          0          0

13 rows selected.

3.1.2数据库缓冲区

数据库缓冲区
     数据库缓冲区是oracle用来执行SQL的工作区域。在更新数据时，用户会话不直接更新磁盘上的数据，而是首先复制到数据库缓冲区缓存。更改应用于数据库缓冲区缓存中这些数据块的副本，块将在缓存中保留一段时间，直至其占有的缓冲区需要缓存另一块为止。在查询数据时，数据也要经过缓存。会话计算出那些块包含关键的行，并将它们复制到数据库缓冲区缓存。此后，相关行传输到会话的PGA作进一步处理。此后数据块会在数据库缓存区缓存中保留一段时间。
   理想状况下，包含频繁访问的数据的所有块将位于数据库缓冲区缓存中，从而最大程度地减少磁盘I/O的需要。如果缓冲区的缓存中存储的块的映像与磁盘上的映像不同，那么这样的缓冲区常称为“脏缓冲区”。脏缓冲区必须写回到数据文件，然后缓冲区又变得干净了。即使再写入磁盘后，此块也仍留在内存中，可能有一段时间，此缓冲区不会被另一个块所重写。
   数据库缓冲区缓存的大小会对性能产生至关重要的影响。缓存应足够大，以便能缓存所有频繁访问的块，但也不能太大，以至于它会缓存极少使用的块。如果缓存过小，那么将导致磁盘活动过多，因为频繁访问的块持续从磁盘读取，并由其他块使用和重写，然后再从磁盘读取。数据库缓冲区缓存在实例启动时分配。从数据库9i开始，可以随时将其调大或调小。可以采用手动方式重调，也可以根据工作负荷自动重调大小（如果启用了自动化机制）。（优化的时候会用到）

修改DB_CACHE_SIZE的方法 

 1查看SGA大小 show parameter sga_max_size  db_cache_size的尺寸受SGA的影响为能大于SGA

2查看show parameter shared_pool_size尺寸

一般来说shared_pool_size+db_cache_size=SGA_MAX_SIZE*70%左右

经过计算再修改db_cache_size

sql>alter system set db_cache_size=大小M  scope=spfile sid='数据库SID';

sql>shutdown immediate

sql>startup

sql>show parameter db_cache_size

就可以看到修改后的效果了

3.1.3日志缓冲区
 日志缓冲区是小型的、用于短期存储将写入到磁盘上的重做日志的变更向量的临时区域。"变更向量"是应用于某些对象的修改，执行DML语句会生成应用于数据的变更向量。有了重做日志，数据库就保证数据永不丢失，每当数据块放生变更时，都会将应用于块的变更向量写到重做日志，如果需要还原数据文件，则通过重做日志，可以将变更向量提取并应用于数据文件备份。
 会话服务器进程不将重做记录直接写入到重做日志文件，否则，每当执行DML语句时，会话将不得不等待磁盘I/O操作完成。相反，会话将重做记录写入内存中的日志缓冲区。这样做的速度将远比写入磁盘快。此后，日志缓冲区写出到重做日志文件。写操作由日志写入器后台进程(LGWR)完成。
 日志缓冲区在启动是实例时分配，如果不重新启动实例，就不能在随后调整其大小。在oracle体系结构中，将日志缓冲区转储到磁盘时基本瓶颈之一。DML的速度不能超过LGER将变更向量转储到联机重做日志文件的速度。如果重做生成是限制数据库性能的因素，唯一的选项是使用RAC，在RAC数据库中，每个实例都有自己的日志缓冲区和自己的LGWR，这是将重做数据并行写入磁盘的唯一方法。

3.1.4大池
   大池是一个可选区域，如果创建了大池，则那些在不创建大池的情况下使用共享池内存的不同进程将自动使用大池。大池的一个主要用途是供共享的服务器进程使用。在缺少大吃的情况下，这些进程将使用共享池中的内存，将导致对共享池的恶性竞争。如果使用的是共享服务器或并行服务器，那么始终应该创建大池。设置大池的大小与性能无关，如果某个进程需要大内存池，而内存不够用，则此进程将失败并发生错误。如果分配的内存超过需要，语句的执行速度并不会因此加快。从9i第2版本开始，用户可以在启动实例后创建大池，并重设其大小。
3.1.5 JAVA池
  只有当应用程序需要在数据库中运行java存储程序时，才需要java池。用户可以在启动实例后创建池并重设池的大小，可以完全自动地创建池，并设置池的大小

  
==================

ORACLE启动过程

ORACLE SERVER由实例(Instance)和数据库(database)组成，而实例是由一组后台进程和一块共享内存区域(sga)组成,而后台进程是数据库和操作系统进行交互的通道，后台进程的命名由ORACLE_SID决定，ORACLE根据ORACLE_SID来寻找参数文件启动实例。数据库是指存储在磁盘上的一组物理文件。

 

ORACLE启动分3个过程：

NOMOUNT状态：启动实例

MOUNT状态：打开控制文件

OPEN状态：打开控制文件中描述的文件

 

NOMOUNT状态：

ORACLE需要寻找SPFILE(oracle 10g默认，pfile也可以)文件，来创建实例和分配内存。

 

MOUNT状态：

在此状态需要打开控制文件，而控制文件中包含日志文件，数据文件的位置信息，检查点信息等重要信息。

在ORACLE9i中，丢失口令文件会报错,可以通过orapw工具重建。在oracle 10g不会报错，通过v$pwfile_users视图查询。

lk_<ORACLE_SID>文件在数据库启动时创建，用于操作系统对数据库的锁定。

口令文件存在$ORACLE_HOME/dbs

 

alter system set controlfile='控制文件路径' scope=spfile;

alter system set lock_name_space=orcl  scope=spfile;

 

重建控制文件：

SQL>startup nomount;

SQL>create controlfile reuse database "orcl" noresetlogs archivelog

maxlogfiles 5

maxlogmembers 3

maxdatafiles 100

maxinstances 1

maxloghistory 1134

logfile

group 3 '/data/app/oracle/oradata/orcl/redo03.log' size 10m,

group 4 '/data/app/oracle/oradata/orcl/redo04.log' size 10m,

group 5 '/data/app/oracle/oradata/orcl/redo05.log' size 10m

datafile

'/data/app/oracle/oradata/orcl/system01.dbf',

'/data/app/oracle/oradata/orcl/undotbs01.dbf',

'/data/app/oracle/oradata/orcl/sysaux01.dbf'

character set zhs16gbk;

 

OPEN状态

首先会检查数据文件头中检查点计数与控制文件中检查点计数是否一致。其次检查数据文件头的开始SCN和控制文件中记录该文件的结束SCN是否一致，如果控制文件中结束的SCN等于数据文件头中开始的SCN，说明不需要恢复。

 

SQL>show parameter backgroud_dump_dest;

如果数据库中的某个文件丢失，那么在MOUNT阶段不会在前台显示告警日志，会记录在alter_<ORACLE_SID>.log中。 

 ==============

 oracle 启动过程

 1.启动选项

在发出startup命令启动数据库时，oracle将在默认位置$ORACLE_HOME/dbs（UNIX/Linux）中查找初始化参数文件。Oracle将以下面的顺序在其中寻找合适的初始化文件：

Spfile$ORACLE_SID.ora

Spfile.ora

Init$ORACLE_SID.ora

可以用几种方式启动oracle数据库。不同方式启动将影响启动数据库的程度。启动状态由nomount(数据库未装载)――>mount(数据库完成装载)――>open(数据库打开)

1.1 STARTUP NOMOUNT命令
复制代码

SQL> startup nomount;
ORACLE instance started.

Total System Global Area  167387136 bytes
Fixed Size                  1343668 bytes
Variable Size             150998860 bytes
Database Buffers           12582912 bytes
Redo Buffers                2461696 bytes

复制代码

--Oracle读参数文件(里面有控制文件目录)，打开实例，启动Oracle后台进程,给Oracle分配SGA。此时数据库状态为未装载。

可以在SQL*Plus会话中使用STARTUP NOMOUNT命令启动实例，这样启动仅有实例运行。如果以这种方式启动，将不读控制文件，而且数据文件也不打开。操作系统启动Oracle后台进程，并且给oracle分配SGA。事实上，只有实例本身在运行。

1.2 STARTUP MOUNT命令
复制代码

SQL> startup mount;
ORACLE instance started.

Total System Global Area  167387136 bytes
Fixed Size                  1343668 bytes
Variable Size             150998860 bytes
Database Buffers           12582912 bytes
Redo Buffers                2461696 bytes
Database mounted.

复制代码

--Oracle 打开并读取控制文件(里面有数据文件和日志文件的目录)，获取数据文件和重做日志文件的名称和位置。此时数据库完成装载。

在启动过程中，oracle把实例与数据库关联。Oracle打开并读取控制文件，获取数据文件和重做日志文件的名称和位置。在进行诸如全数据库恢复、更改数据库的归档日志模式或重命名数据文件这一类的活动时，通常需要以安装模式启动数据库。请注意，这三种操作都要求oracle访问数据文件，但不提供对文件的用户操作。

1.3 STARTUP [OPEN]命令
复制代码

SQL> startup open
ORACLE instance started.

Total System Global Area  167387136 bytes
Fixed Size                  1343668 bytes
Variable Size             150998860 bytes
Database Buffers           12582912 bytes
Redo Buffers                2461696 bytes
Database mounted.
Database opened.

复制代码

--Oracle打开数据文件和重做日志文件，才能对外(所有有效用户)提供数据库服务。

启动过程的最后一步是打开数据库。当数据库以打开模式启动时，所有有效用户可以连接到数据库，执行数据库操作。在此步骤之前，一般用户根本就不能连接到数据库。通过发布下面的命令让数据库出于打开模式。

=====================

oraclesql语句执行原理和完整过程详解
http://www.cnblogs.com/kerrycode/p/3356845.html

SQL语句在数据库中处理过程是怎样的呢？执行顺序呢？在回答这个问题前，我们先来回顾一下：在ORACLE数据库系统架构下，SQL语句由用户进程产生，然后传到相对应的服务端进程，之后由服务器进程执行该SQL语句，如果是SELECT语句，服务器进程还需要将执行结果回传给用户进程。

SQL语句的执行过程一般如下：

解析（PARSE）―― 绑定（BIND）――执行（EXECUTE）――提取（FETCH 只有SELECT才需要这步）

clip_image001

解析

 

服务器进程接收到一个SQL语句时，首先要将其转换成执行这个SQL语句的最有效步骤，这些步骤被称为执行计划。

Step 1：检查共享池中是否有之前解析相同的SQL语句后所存储的SQL文本、解析树和执行计划。如果能从共享池的缓存库中找到之前解析过生成的执行计划，则SQL语句则不需要再次解析，便可以直接由库缓存得到之前所产生的执行计划，从而直接跳到绑定或执行阶段，这种解析称作软解析。

但是如果在共享池的库缓存中找不到对应的执行计划，则必须继续解析SQL、生成执行计划，这种解析称作硬解析

在缓存池解析过的SQL，会有一个对应的哈希值与之对应，你可以通过V$SQL视图来查询，请看下面一个例子：
复制代码

SQL>SELECT * FROM SCOTT.DEPT WHERE DEPTNO =10;

SQL>SELECT * FROM SCOTT.DEPT WHERE DEPTNO =20;

SQL> SELECT HASH_VALUE , ADDRESS, EXECUTIONS ,SQL_TEXT

2 FROM V$SQL

3 WHERE SQL_TEXT LIKE 'SELECT * FROM SCOTT.DEPT WHERE DEPTNO%'

4 ;

HASH_VALUE ADDRESS EXECUTIONS SQL_TEXT

---------- -------- ---------- --------------------------------------------------------------------------------

442836625 27EE4B7C 1 SELECT * FROM SCOTT.DEPT WHERE DEPTNO =20

4215405494 27EEA3BC 1 SELECT * FROM SCOTT.DEPT WHERE DEPTNO =10

复制代码

 

 下面我们先清空共享池缓存的执行计划，然后使用绑定变量，查看执行计划的变换

 
复制代码

SQL> ALTER SYSTEM FLUSH SHARED_POOL;

System altered

SQL> VARIABLE deptno NUMBER;

SQL> EXECUTE :deptno := 10;

PL/SQL procedure successfully completed

deptno

---------

10

SQL> SELECT * FROM SCOTT.DEPT WHERE DEPTNO=:deptno;

DEPTNO DNAME LOC

------ -------------- -------------

10 ACCOUNTING NEW YORK

SQL> EXECUTE :deptno :=20;

PL/SQL procedure successfully completed

deptno

---------

20

SQL> SELECT * FROM SCOTT.DEPT WHERE DEPTNO=:deptno;

DEPTNO DNAME LOC

------ -------------- -------------

20 RESEARCH DALLAS

SQL> SELECT HASH_VALUE , ADDRESS, EXECUTIONS ,SQL_TEXT

2 FROM V$SQL

3 WHERE SQL_TEXT LIKE ' SELECT * FROM SCOTT.DEPT WHERE DEPTNO%';

HASH_VALUE ADDRESS EXECUTIONS SQL_TEXT

---------- -------- ---------- --------------------------------------------------------------------------------

3669302979 27D2BA1C 2 SELECT * FROM SCOTT.DEPT WHERE DEPTNO=:deptno

复制代码

 

Step 2：语法分析，分析SQL语句的语法是否符合规范，衡量语句中各表达式的意义

Step 3：检查是否存在语义错误和权限。语义分析，检查语句中设计的所有数据库对象是否存在，且用户有相应的权限。

Step 4：视图转换和表达式转换 将涉及视图的查询语句转换为相应的对基表查询语句。将复杂表达式转化较为简单的等效连接表达式。

Step 5：决定最佳执行计划。优化器会生成多个执行计划，在按统计信息带入，找出执行成本最小的执行计划，作为执行此SQL语句的执行计划

Step 6：将SQL文本、解析树、执行计划缓存到库缓存，存放地址以及SQL语句的哈希值。

绑定

如果SQL语句中使用了绑定变量，扫描绑定变量的声明，给绑定变量赋值。则此时将变量值带入执行计划。

执行

 

此阶段按照执行计划执行SQL，产生执行结果。不同类型的SQL语句，执行过程也不同。

SELECT查询

检查所需的数据块是否已经在缓冲区缓存中，如果已经在缓冲区缓存中，直接读取器内容即可。这种读取方式称为逻辑读取。如果所需数据不在缓冲区缓存中，则服务器进程需要先扫描数据块，读取相应数据块到缓冲区缓存，这种读取方式称为物理读。和逻辑读相比较，它更加耗费CPU和IO资源。

修改操作（INSERT、UPDATE、DELETE）

Step 1：检查所需的数据库是否已经被读取到缓冲区缓存中。如果已经存在缓冲区缓存，则执行Step 3

Step 2：若所需的数据库并不在缓冲区缓存中，则服务器将数据块从数据文件读取到缓冲区缓存中

Step 3：对想要修改的表取得的数据行锁定（Row Exclusive Lock），之后对所需要修改的数据行取得独占锁

Step 4：将撤销数据的Redo记录复制到日志缓冲区，产生数据行的撤销数据，将数据行修改的Redo记录复制到日志缓冲区，修改数据行。

Step 5: 产生数据修改的撤销数据

Step 6：复制数据修改的Redo记录到日志缓冲区

Step 7：修改数据行的内容，如果之前的缓冲为干净缓冲，则此时将变为脏缓冲。

提取

提取只有SELECT查询语句才有的步骤。获取查询的记录行，必要的时候对查询结果排序。

=====================

oraclesql语句执行原理和完整过程详解

http://blog.csdn.net/chenjie19891104/article/details/6657289

最近项目做完了（也许并不能说做完了），但是出现了一个致命的障碍，就是性能。现在想想TOP的作者是讲的是多么的精辟，性能是贯穿在项目需求，项目分析设计，项目编码和单元测试、集成等各个阶段。而不是等项目开发完毕，再来考虑性能问题。但是，事实已是如此。所以，最近先从SQL语句开始优化， 为了更好地优化SQL，那么首先自然需要知道Oracle中的SQL引擎对一条给定的SQL语句，他都做了哪些鲜为人知的事情。本文为个人学习总结，仅作学习记录，其中不妥或者错误之处，敬请指出，本人感激不尽！

为了延续TOP中从Cursor开始说明，这里的Cursor并非PL/SQL中的Cursor，至于这个Cursor是什么，怎么用中文解释，暂时还不清楚。但是我想他其实是一个概念性的东西，代表了SQL在不同环境中的称谓。顽皮点地说，当一条SQL语句进入了SQL引擎，其就被Cursor了。下面看一张TOP上的Cursor的生命周期：


1:Open Cursor：在本次会话的服务器进程的私有内存UGA（User Global Area）中会开辟一个内存区给这个Cursor。此时，SQL语句还没有和该Cursor相关联。

2:Parse Cursor：这个过程就会让SQL语句和Cursor相关联了。这个步骤就是通常意义的SQL解析，最后将执行计划存入共享区。然后UGA中的Cursor会用一个指针指向共享区的一个可共享的Cursor。

3:Define output variables：定义输出变量主要是对于查询和使用了returning语法的insert，update，和delete语句。

4:Bind input variables：如果SQL使用了绑定变量，则这里需要获取绑定变量的值。

5:Execute cursor：执行，但是SQL语句真正的执行往往会延迟到下个步骤。

6:Fetch cursor：如果sql返回数据，则这里获取返回的数据。

7:Close cursor：关闭cursor，释放UGA中占用的资源。但是共享区中的cursor并不会释放。

在上面这个过程中，对于我们关心的SQL语句的解析，一笔带过。下面继续分析第二个步骤Parse Cursor。对于SQL语句的解析，早就听说是软解析和硬解析，下面我们分析下整个解析的过程：

1、整个解析的过程从包含VPD的谓词开始。如果该SQL中含有应用了VPD(Virtual Private Database)的表，则将会首先在SQL语句的where中附加上VPD安全策略的谓词。

2、语法、语义检查和权限控制。语法检查，对sql语句关键字的正确性进行检查，语义检查主要判断该SQL中是否引用了不存在的对象或者是否违反了相关约束条件；权限控制

主要是判断当前操作是否具备相应的操作权限。

3、从共享区中获取一个Parent Cursor，如果未获取到，则在共享区中分配内存，定义一个新的Parent Cursor。这个Parent Cursor结构的关键信息就是这个SQL语句本身。

4、逻辑优化，这个过程应用各种不同的算法和策略对SQL语句进行转换，生成很多等价的SQL。

5、物理优化，首先将上个步骤中各SQL语句生成各自的执行计划，然后应用系统数据字典中的分析统计信息或者通过动态采样获取的统计信息为每个执行计划计算出一个Cost，然后选择最小Cost的执行计划。

6、在共享区中存储一个Child Cursor，这个Child Cursor和上面Parent Cursor是关联的，Child Cursor中主要存储执行计划和运行环境信息。

通过上面，可以看到，在共享区中有一个Parent Cursor和Child Cursor来保存一个SQL语句的信息，通过查询v$sqlarea,v$sql,v$sqltext等视图，我们可以获取sql和cursor的相关信息。

对于上面的各个过程，我们看到，Parent Cursor和Child Cursor是在共享区的，也就是说其可以被共享，嘿嘿，这就是为什么有软解析和硬解析了。

软解析：如果Parent Cursor和Child Cursor在共享区中已经存在，则只需要前两个步骤就行了。这个就是软解析。

硬解析：如果Parent Cursor和Child Cursor不能共享，则需要完整的过程，这个就是硬解析了。

下面通过一个例子来说明关于共享的机制和需要注意的问题。

首先，对于如下几个查询语句

select * from t where n = 1024;

Select * from t where n = 1024;

select  *  from t where n = 1024;

select * from t where n = 1024;

执行上面四条查询语句，然后，我们查看v$sqlarea视图发现，第一条和第四条是相同的，只需要硬解析一次，当第二次执行的时候就不需要硬解析了，所以第一条语句的执行次数是2。这里就说明SQL语句必须完全相同才能共享Parent Cursor。

select sql_id,sql_text,executions from v$sqlarea where  sql_text like '%n=1024%';结果就不贴了。


绑定变量：对于绑定变量，其对于开发来说，或许会增加其代码量。从性能的角度来说，其对OLTP系统的影响巨大，很多系统的瘫痪，归根于此。比如，对于如下的查询语句，select * from t where n = 1024;如果在程序中，我们构造SQL语句的时候，使用如下的代码：

private String buildSQL(int n){

    StringBuilder sb = new StringBuilder("select * from t where n = ");

    sb.append(n);

    return sb.toString();

}

那么，如果应用程序中这个n假如有10万个不同的值，如果这些都被执行了，则在共享区就会存储10万条共享记录。因为对于每个不同的值，其SQL就是两条完全不同的SQL。

所以，建议在OLTP系统当中尽可能使用绑定变量的方式构造SQL语句。但是绑定变量，也会造成执行计划可能并非最优的。比如：

select * from t where c < 1000;

如果这个查询的结果记录数为总数据的90%，则执行计划将会选择全表扫描，而不会走索引。

select * from t where c < 10;

对于这个查询，优化器肯定会走索引，而不会走全表扫描。

但是当使用绑定变量的时候，查询语句就是select * from t where c < :c ;这样优化器并不能知道当前查询的记录数的情况，所以，在生成执行计划的时候，可能最后选择的执行计划并不是最优的。

关于这个，在9i中好像得到了改善，增加了bind variable peeking，在硬解析的过程中会将绑定变量的值加上，再生成执行计划。

======================

Oracle SQL Performance
http://www.cnblogs.com/rootq/archive/2008/11/17/1334727.html

Oracle SQL性能优化

（1）      选择最有效率的表名顺序(只在基于规则的优化器中有效)：
ORACLE的解析器按照从右到左的顺序处理FROM子句中的表名，FROM子句中写在最后的表(基础表 driving table)将被最先处理，在FROM子句中包含多个表的情况下,你必须选择记录条数最少的表作为基础表。如果有3个以上的表连接查询, 那就需要选择交叉表(intersection table)作为基础表, 交叉表是指那个被其他表所引用的表.
（2）      WHERE子句中的连接顺序．：
ORACLE采用自下而上的顺序解析WHERE子句,根据这个原理,表之间的连接必须写在其他WHERE条件之前, 那些可以过滤掉最大数量记录的条件必须写在WHERE子句的末尾.
（3）      SELECT子句中避免使用 ‘ * ‘：
ORACLE在解析的过程中, 会将'*' 依次转换成所有的列名, 这个工作是通过查询数据字典完成的, 这意味着将耗费更多的时间
（4）      减少访问数据库的次数：
ORACLE在内部执行了许多工作: 解析SQL语句, 估算索引的利用率, 绑定变量 , 读数据块等；
（5）      在SQL*Plus , SQL*Forms和Pro*C中重新设置ARRAYSIZE参数, 可以增加每次数据库访问的检索数据量 ,建议值为200
（6）      使用DECODE函数来减少处理时间：
使用DECODE函数可以避免重复扫描相同记录或重复连接相同的表.
（7）      整合简单,无关联的数据库访问：
如果你有几个简单的数据库查询语句,你可以把它们整合到一个查询中(即使它们之间没有关系)
（8）      删除重复记录：
最高效的删除重复记录方法 ( 因为使用了ROWID)例子：
DELETE  FROM  EMP E  WHERE  E.ROWID > (SELECT MIN(X.ROWID)
FROM  EMP X  WHERE  X.EMP_NO = E.EMP_NO);
（9）      用TRUNCATE替代DELETE：
当删除表中的记录时,在通常情况下, 回滚段(rollback segments ) 用来存放可以被恢复的信息. 如果你没有COMMIT事务,ORACLE会将数据恢复到删除之前的状态(准确地说是恢复到执行删除命令之前的状况) 而当运用TRUNCATE时, 回滚段不再存放任何可被恢复的信息.当命令运行后,数据不能被恢复.因此很少的资源被调用,执行时间也会很短. (译者按: TRUNCATE只在删除全表适用,TRUNCATE是DDL不是DML)
（10） 尽量多使用COMMIT：
只要有可能,在程序中尽量多使用COMMIT, 这样程序的性能得到提高,需求也会因为COMMIT所释放的资源而减少:
COMMIT所释放的资源:
a. 回滚段上用于恢复数据的信息.
b. 被程序语句获得的锁
c. redo log buffer 中的空间
d. ORACLE为管理上述3种资源中的内部花费
（11） 用Where子句替换HAVING子句：
避免使用HAVING子句, HAVING 只会在检索出所有记录之后才对结果集进行过滤. 这个处理需要排序,总计等操作. 如果能通过WHERE子句限制记录的数目,那就能减少这方面的开销. (非oracle中)on、where、having这三个都可以加条件的子句中，on是最先执行，where次之，having最后，因为on是先把不符合条件的记录过滤后才进行统计，它就可以减少中间运算要处理的数据，按理说应该速度是最快的，where也应该比having快点的，因为它过滤数据后才进行sum，在两个表联接时才用on的，所以在一个表的时候，就剩下where跟having比较了。在这单表查询统计的情况下，如果要过滤的条件没有涉及到要计算字段，那它们的结果是一样的，只是where可以使用rushmore技术，而having就不能，在速度上后者要慢如果要涉及到计算的字段，就表示在没计算之前，这个字段的值是不确定的，根据上篇写的工作流程，where的作用时间是在计算之前就完成的，而having就是在计算后才起作用的，所以在这种情况下，两者的结果会不同。在多表联接查询时，on比where更早起作用。系统首先根据各个表之间的联接条件，把多个表合成一个临时表后，再由where进行过滤，然后再计算，计算完后再由having进行过滤。由此可见，要想过滤条件起到正确的作用，首先要明白这个条件应该在什么时候起作用，然后再决定放在那里
（12） 减少对表的查询：
在含有子查询的SQL语句中,要特别注意减少对表的查询.例子：
     SELECT  TAB_NAME FROM TABLES WHERE (TAB_NAME,DB_VER) = ( SELECT
TAB_NAME,DB_VER FROM  TAB_COLUMNS  WHERE  VERSION = 604)
（13） 通过内部函数提高SQL效率.：
复杂的SQL往往牺牲了执行效率. 能够掌握上面的运用函数解决问题的方法在实际工作中是非常有意义的
（14） 使用表的别名(Alias)：
当在SQL语句中连接多个表时, 请使用表的别名并把别名前缀于每个Column上.这样一来,就可以减少解析的时间并减少那些由Column歧义引起的语法错误.
（15） 用EXISTS替代IN、用NOT EXISTS替代NOT IN：
在许多基于基础表的查询中,为了满足一个条件,往往需要对另一个表进行联接.在这种情况下, 使用EXISTS(或NOT EXISTS)通常将提高查询的效率. 在子查询中,NOT IN子句将执行一个内部的排序和合并. 无论在哪种情况下,NOT IN都是最低效的 (因为它对子查询中的表执行了一个全表遍历). 为了避免使用NOT IN ,我们可以把它改写成外连接(Outer Joins)或NOT EXISTS.
例子：
（高效）SELECT * FROM  EMP (基础表)  WHERE  EMPNO > 0  AND  EXISTS (SELECT ‘X'  FROM DEPT  WHERE  DEPT.DEPTNO = EMP.DEPTNO  AND  LOC = ‘MELB')
(低效)SELECT  * FROM  EMP (基础表)  WHERE  EMPNO > 0  AND  DEPTNO IN(SELECT DEPTNO  FROM  DEPT  WHERE  LOC = ‘MELB')
（16） 识别'低效执行'的SQL语句：
虽然目前各种关于SQL优化的图形化工具层出不穷,但是写出自己的SQL工具来解决问题始终是一个最好的方法：
SELECT  EXECUTIONS , DISK_READS, BUFFER_GETS,
ROUND((BUFFER_GETS-DISK_READS)/BUFFER_GETS,2) Hit_radio,
ROUND(DISK_READS/EXECUTIONS,2) Reads_per_run,
SQL_TEXT
FROM  V$SQLAREA
WHERE  EXECUTIONS>0
AND  BUFFER_GETS > 0
AND  (BUFFER_GETS-DISK_READS)/BUFFER_GETS < 0.8
ORDER BY  4 DESC;

 

（17） 用索引提高效率：
索引是表的一个概念部分,用来提高检索数据的效率，ORACLE使用了一个复杂的自平衡B-tree结构. 通常,通过索引查询数据比全表扫描要快. 当ORACLE找出执行查询和Update语句的最佳路径时, ORACLE优化器将使用索引. 同样在联结多个表时使用索引也可以提高效率. 另一个使用索引的好处是,它提供了主键(primary key)的唯一性验证.。那些LONG或LONG RAW数据类型, 你可以索引几乎所有的列. 通常, 在大型表中使用索引特别有效. 当然,你也会发现, 在扫描小表时,使用索引同样能提高效率. 虽然使用索引能得到查询效率的提高,但是我们也必须注意到它的代价. 索引需要空间来存储,也需要定期维护, 每当有记录在表中增减或索引列被修改时, 索引本身也会被修改. 这意味着每条记录的INSERT , DELETE , UPDATE将为此多付出4 , 5 次的磁盘I/O . 因为索引需要额外的存储空间和处理,那些不必要的索引反而会使查询反应时间变慢.。定期的重构索引是有必要的.：
ALTER  INDEX <INDEXNAME> REBUILD <TABLESPACENAME>
（18） 用EXISTS替换DISTINCT：
当提交一个包含一对多表信息(比如部门表和雇员表)的查询时,避免在SELECT子句中使用DISTINCT. 一般可以考虑用EXIST替换, EXISTS 使查询更为迅速,因为RDBMS核心模块将在子查询的条件一旦满足后,立刻返回结果. 例子：
       (低效):
SELECT  DISTINCT  DEPT_NO,DEPT_NAME  FROM  DEPT D , EMP E
WHERE  D.DEPT_NO = E.DEPT_NO
(高效):
SELECT  DEPT_NO,DEPT_NAME  FROM  DEPT D  WHERE  EXISTS ( SELECT ‘X'
FROM  EMP E  WHERE E.DEPT_NO = D.DEPT_NO);
（19） sql语句用大写的；因为oracle总是先解析sql语句，把小写的字母转换成大写的再执行
（20） 在java代码中尽量少用连接符“＋”连接字符串！
（21） 避免在索引列上使用NOT 通常，　
我们要避免在索引列上使用NOT, NOT会产生在和在索引列上使用函数相同的影响. 当ORACLE”遇到”NOT,他就会停止使用索引转而执行全表扫描.
（22） 避免在索引列上使用计算．
WHERE子句中，如果索引列是函数的一部分．优化器将不使用索引而使用全表扫描．
举例:
低效：
SELECT … FROM  DEPT  WHERE SAL * 12 > 25000;
高效:
SELECT … FROM DEPT WHERE SAL > 25000/12;
（23） 用>=替代>
高效:
SELECT * FROM  EMP  WHERE  DEPTNO >=4
低效:
SELECT * FROM EMP WHERE DEPTNO >3
两者的区别在于, 前者DBMS将直接跳到第一个DEPT等于4的记录而后者将首先定位到DEPTNO=3的记录并且向前扫描到第一个DEPT大于3的记录.
（24） 用UNION替换OR (适用于索引列)
通常情况下, 用UNION替换WHERE子句中的OR将会起到较好的效果. 对索引列使用OR将造成全表扫描. 注意, 以上规则只针对多个索引列有效. 如果有column没有被索引, 查询效率可能会因为你没有选择OR而降低. 在下面的例子中, LOC_ID 和REGION上都建有索引.
高效:
SELECT LOC_ID , LOC_DESC , REGION
FROM LOCATION
WHERE LOC_ID = 10
UNION
SELECT LOC_ID , LOC_DESC , REGION
FROM LOCATION
WHERE REGION = “MELBOURNE”
低效:
SELECT LOC_ID , LOC_DESC , REGION
FROM LOCATION
WHERE LOC_ID = 10 OR REGION = “MELBOURNE”
如果你坚持要用OR, 那就需要返回记录最少的索引列写在最前面.
（25） 用IN来替换OR  
这是一条简单易记的规则，但是实际的执行效果还须检验，在ORACLE8i下，两者的执行路径似乎是相同的．　
低效:
SELECT…. FROM LOCATION WHERE LOC_ID = 10 OR LOC_ID = 20 OR LOC_ID = 30
高效
SELECT… FROM LOCATION WHERE LOC_IN  IN (10,20,30);
（26） 避免在索引列上使用IS NULL和IS NOT NULL
避免在索引中使用任何可以为空的列，ORACLE将无法使用该索引．对于单列索引，如果列包含空值，索引中将不存在此记录. 对于复合索引，如果每个列都为空，索引中同样不存在此记录.　如果至少有一个列不为空，则记录存在于索引中．举例: 如果唯一性索引建立在表的A列和B列上, 并且表中存在一条记录的A,B值为(123,null) , ORACLE将不接受下一条具有相同A,B值（123,null）的记录(插入). 然而如果所有的索引列都为空，ORACLE将认为整个键值为空而空不等于空. 因此你可以插入1000 条具有相同键值的记录,当然它们都是空! 因为空值不存在于索引列中,所以WHERE子句中对索引列进行空值比较将使ORACLE停用该索引.
低效: (索引失效)
SELECT … FROM  DEPARTMENT  WHERE  DEPT_CODE IS NOT NULL;
高效: (索引有效)
SELECT … FROM  DEPARTMENT  WHERE  DEPT_CODE >=0;
（27） 总是使用索引的第一个列：
如果索引是建立在多个列上, 只有在它的第一个列(leading column)被where子句引用时,优化器才会选择使用该索引. 这也是一条简单而重要的规则，当仅引用索引的第二个列时,优化器使用了全表扫描而忽略了索引
（28） 用UNION-ALL 替换UNION ( 如果有可能的话)：
当SQL语句需要UNION两个查询结果集合时,这两个结果集合会以UNION-ALL的方式被合并, 然后在输出最终结果前进行排序. 如果用UNION ALL替代UNION, 这样排序就不是必要了. 效率就会因此得到提高. 需要注意的是，UNION ALL 将重复输出两个结果集合中相同记录. 因此各位还是要从业务需求分析使用UNION ALL的可行性. UNION 将对结果集合排序,这个操作会使用到SORT_AREA_SIZE这块内存. 对于这块内存的优化也是相当重要的. 下面的SQL可以用来查询排序的消耗量
低效：
SELECT  ACCT_NUM, BALANCE_AMT
FROM  DEBIT_TRANSACTIONS
WHERE TRAN_DATE = '31-DEC-95'
UNION
SELECT ACCT_NUM, BALANCE_AMT
FROM DEBIT_TRANSACTIONS
WHERE TRAN_DATE = '31-DEC-95'
高效:
SELECT ACCT_NUM, BALANCE_AMT
FROM DEBIT_TRANSACTIONS
WHERE TRAN_DATE = '31-DEC-95'
UNION ALL
SELECT ACCT_NUM, BALANCE_AMT
FROM DEBIT_TRANSACTIONS
WHERE TRAN_DATE = '31-DEC-95'
（29） 用WHERE替代ORDER BY：
ORDER BY 子句只在两种严格的条件下使用索引.
ORDER BY中所有的列必须包含在相同的索引中并保持在索引中的排列顺序.
ORDER BY中所有的列必须定义为非空.
WHERE子句使用的索引和ORDER BY子句中所使用的索引不能并列.
例如:
表DEPT包含以下列:
DEPT_CODE PK NOT NULL
DEPT_DESC NOT NULL
DEPT_TYPE NULL
低效: (索引不被使用)
SELECT DEPT_CODE FROM  DEPT  ORDER BY  DEPT_TYPE
高效: (使用索引)
SELECT DEPT_CODE  FROM  DEPT  WHERE  DEPT_TYPE > 0
（30） 避免改变索引列的类型.:
当比较不同数据类型的数据时, ORACLE自动对列进行简单的类型转换.
假设 EMPNO是一个数值类型的索引列.
SELECT …  FROM EMP  WHERE  EMPNO = ‘123'
实际上,经过ORACLE类型转换, 语句转化为:
SELECT …  FROM EMP  WHERE  EMPNO = TO_NUMBER(‘123')
幸运的是,类型转换没有发生在索引列上,索引的用途没有被改变.
现在,假设EMP_TYPE是一个字符类型的索引列.
SELECT …  FROM EMP  WHERE EMP_TYPE = 123
这个语句被ORACLE转换为:
SELECT …  FROM EMP  WHERETO_NUMBER(EMP_TYPE)=123
因为内部发生的类型转换, 这个索引将不会被用到! 为了避免ORACLE对你的SQL进行隐式的类型转换, 最好把类型转换用显式表现出来. 注意当字符和数值比较时, ORACLE会优先转换数值类型到字符类型
（31） 需要当心的WHERE子句:
某些SELECT 语句中的WHERE子句不使用索引. 这里有一些例子.
在下面的例子里, (1)‘!=' 将不使用索引. 记住, 索引只能告诉你什么存在于表中, 而不能告诉你什么不存在于表中. (2) ‘||'是字符连接函数. 就象其他函数那样, 停用了索引. (3) ‘+'是数学函数. 就象其他数学函数那样, 停用了索引. (4)相同的索引列不能互相比较,这将会启用全表扫描.
（32） a. 如果检索数据量超过30%的表中记录数.使用索引将没有显著的效率提高.
b. 在特定情况下, 使用索引也许会比全表扫描慢, 但这是同一个数量级上的区别. 而通常情况下,使用索引比全表扫描要块几倍乃至几千倍!
（33） 避免使用耗费资源的操作:
带有DISTINCT,UNION,MINUS,INTERSECT,ORDER BY的SQL语句会启动SQL引擎
执行耗费资源的排序(SORT)功能. DISTINCT需要一次排序操作, 而其他的至少需要执行两次排序. 通常, 带有UNION, MINUS , INTERSECT的SQL语句都可以用其他方式重写. 如果你的数据库的SORT_AREA_SIZE调配得好, 使用UNION , MINUS, INTERSECT也是可以考虑的, 毕竟它们的可读性很强
（34） 优化GROUP BY:
提高GROUP BY 语句的效率, 可以通过将不需要的记录在GROUP BY 之前过滤掉.下面两个查询返回相同结果但第二个明显就快了许多.
低效:
SELECT JOB , AVG(SAL)
FROM EMP
GROUP JOB
HAVING JOB = ‘PRESIDENT'
OR JOB = ‘MANAGER'
高效:
SELECT JOB , AVG(SAL)
FROM EMP
WHERE JOB = ‘PRESIDENT'
OR JOB = ‘MANAGER'
GROUP JOB






