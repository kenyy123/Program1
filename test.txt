
grep

http://www.cnblogs.com/ggjucheng/archive/2013/01/13/2856896.html

简介

grep (global search regular expression(RE) and print out the line,全面搜索正则表达式并把行打印出来)是一种强大的文本搜索工具，它能使用正则表达式搜索文本，并把匹配的行打印出来。

Unix的grep家族包括grep、egrep和fgrep。egrep和fgrep的命令只跟grep有很小不同。egrep是grep的扩展，支持更多的re元字符， fgrep就是fixed grep或fast grep，它们把所有的字母都看作单词，也就是说，正则表达式中的元字符表示回其自身的字面意义，不再特殊。linux使用GNU版本的grep。它功能更强，可以通过-G、-E、-F命令行选项来使用egrep和fgrep的功能。

 
grep常用用法
复制代码

[root@www ~]# grep [-acinv] [--color=auto] '搜寻字符串' filename
选项与参数：
-a ：将 binary 文件以 text 文件的方式搜寻数据
-c ：计算找到 '搜寻字符串' 的次数
-i ：忽略大小写的不同，所以大小写视为相同
-n ：顺便输出行号
-v ：反向选择，亦即显示出没有 '搜寻字符串' 内容的那一行！
--color=auto ：可以将找到的关键词部分加上颜色的显示喔！


 
将/etc/passwd，有出现 root 的行取出来
复制代码

# grep root /etc/passwd
root:x:0:0:root:/root:/bin/bash
operator:x:11:0:operator:/root:/sbin/nologin
或
# cat /etc/passwd | grep root 
root:x:0:0:root:/root:/bin/bash
operator:x:11:0:operator:/root:/sbin/nologin



将/etc/passwd，有出现 root 的行取出来,同时显示这些行在/etc/passwd的行号

# grep -n root /etc/passwd
1:root:x:0:0:root:/root:/bin/bash
30:operator:x:11:0:operator:/root:/sbin/nologin

 在关键字的显示方面，grep 可以使用 --color=auto 来将关键字部分使用颜色显示。 这可是个很不错的功能啊！但是如果每次使用 grep 都得要自行加上 --color=auto 又显的很麻烦～ 此时那个好用的 alias 就得来处理一下啦！你可以在 ~/.bashrc 内加上这行：『alias grep='grep --color=auto'』再以『 source ~/.bashrc 』来立即生效即可喔！ 这样每次运行 grep 他都会自动帮你加上颜色显示啦

 

将/etc/passwd，将没有出现 root 的行取出来

# grep -v root /etc/passwd
root:x:0:0:root:/root:/bin/bash
operator:x:11:0:operator:/root:/sbin/nologin

 

将/etc/passwd，将没有出现 root 和nologin的行取出来

# grep -v root /etc/passwd | grep -v nologin
root:x:0:0:root:/root:/bin/bash
operator:x:11:0:operator:/root:/sbin/nologin

 

用 dmesg 列出核心信息，再以 grep 找出内含 eth 那行,要将捉到的关键字显色，且加上行号来表示：

[root@www ~]# dmesg | grep -n --color=auto 'eth'
247:eth0: RealTek RTL8139 at 0xee846000, 00:90:cc:a6:34:84, IRQ 10
248:eth0: Identified 8139 chip type 'RTL-8139C'
294:eth0: link up, 100Mbps, full-duplex, lpa 0xC5E1
305:eth0: no IPv6 routers present
# 你会发现除了 eth 会有特殊颜色来表示之外，最前面还有行号喔！

在关键字的显示方面，grep 可以使用 --color=auto 来将关键字部分使用颜色显示。 这可是个很不错的功能啊！但是如果每次使用 grep 都得要自行加上 --color=auto 又显的很麻烦～ 此时那个好用的 alias 就得来处理一下啦！你可以在 ~/.bashrc 内加上这行：『alias grep='grep --color=auto'』再以『 source ~/.bashrc 』来立即生效即可喔！ 这样每次运行 grep 他都会自动帮你加上颜色显示啦

 

用 dmesg 列出核心信息，再以 grep 找出内含 eth 那行,在关键字所在行的前两行与后三行也一起捉出来显示


[root@www ~]# dmesg | grep -n -A3 -B2 --color=auto 'eth'
245-PCI: setting IRQ 10 as level-triggered
246-ACPI: PCI Interrupt 0000:00:0e.0[A] -> Link [LNKB] ...
247:eth0: RealTek RTL8139 at 0xee846000, 00:90:cc:a6:34:84, IRQ 10
248:eth0: Identified 8139 chip type 'RTL-8139C'
249-input: PC Speaker as /class/input/input2
250-ACPI: PCI Interrupt 0000:00:01.4[B] -> Link [LNKB] ...
251-hdb: ATAPI 48X DVD-ROM DVD-R-RAM CD-R/RW drive, 2048kB Cache, UDMA(66)
# 如上所示，你会发现关键字 247 所在的前两行及 248 后三行也都被显示出来！
# 这样可以让你将关键字前后数据捉出来进行分析啦！



 

根据文件内容递归查找目录

# grep ‘energywise’ *           #在当前目录搜索带'energywise'行的文件

# grep -r ‘energywise’ *        #在当前目录及其子目录下搜索'energywise'行的文件

# grep -l -r ‘energywise’ *     #在当前目录及其子目录下搜索'energywise'行的文件，但是不显示匹配的行，只显示匹配的文件

这几个命令很使用，是查找文件的利器。

 
grep与正规表达式

 字符类

字符类的搜索：如果我想要搜寻 test 或 taste 这两个单字时，可以发现到，其实她们有共通的 't?st' 存在～这个时候，我可以这样来搜寻：

[root@www ~]# grep -n 't[ae]st' regular_express.txt
8:I can't finish the test.
9:Oh! The soup taste good.


其实 [] 里面不论有几个字节，他都谨代表某『一个』字节， 所以，上面的例子说明了，我需要的字串是『tast』或『test』两个字串而已！

 

字符类的反向选择 [^] ：如果想要搜索到有 oo 的行，但不想要 oo 前面有 g，如下

[root@www ~]# grep -n '[^g]oo' regular_express.txt
2:apple is my favorite food.
3:Football game is not use feet only.
18:google is the best tools for search keyword.
19:goooooogle yes!

第 2,3 行没有疑问，因为 foo 与 Foo 均可被接受！

但是第 18 行明明有 google 的 goo 啊～别忘记了，因为该行后面出现了 tool 的 too 啊！所以该行也被列出来～ 也就是说， 18 行里面虽然出现了我们所不要的项目 (goo) 但是由於有需要的项目 (too) ， 因此，是符合字串搜寻的喔！

至於第 19 行，同样的，因为 goooooogle 里面的 oo 前面可能是 o ，例如： go(ooo)oogle ，所以，这一行也是符合需求的！

 

字符类的连续：再来，假设我 oo 前面不想要有小写字节，所以，我可以这样写 [^abcd....z]oo ， 但是这样似乎不怎么方便，由於小写字节的 ASCII 上编码的顺序是连续的， 因此，我们可以将之简化为底下这样：

[root@www ~]# grep -n '[^a-z]oo' regular_express.txt
3:Football game is not use feet only.

也就是说，当我们在一组集合字节中，如果该字节组是连续的，例如大写英文/小写英文/数字等等， 就可以使用[a-z],[A-Z],[0-9]等方式来书写，那么如果我们的要求字串是数字与英文呢？ 呵呵！就将他全部写在一起，变成：[a-zA-Z0-9]。

我们要取得有数字的那一行，就这样：

[root@www ~]# grep -n '[0-9]' regular_express.txt
5:However, this dress is about $ 3183 dollars.
15:You are the best is mean you are the no. 1.

 

行首与行尾字节 ^ $
行首字符：如果我想要让 the 只在行首列出呢？ 这个时候就得要使用定位字节了！我们可以这样做：

[root@www ~]# grep -n '^the' regular_express.txt
12:the symbol '*' is represented as start.

 


此时，就只剩下第 12 行，因为只有第 12 行的行首是 the 开头啊～此外， 如果我想要开头是小写字节的那一行就列出呢？可以这样：


[root@www ~]# grep -n '^[a-z]' regular_express.txt
2:apple is my favorite food.
4:this dress doesn't fit me.
10:motorcycle is cheap than car.
12:the symbol '*' is represented as start.
18:google is the best tools for search keyword.
19:goooooogle yes!
20:go! go! Let's go.



 

如果我不想要开头是英文字母，则可以是这样：

[root@www ~]# grep -n '^[^a-zA-Z]' regular_express.txt
1:"Open Source" is a good mechanism to develop programs.
21:# I am VBird

^ 符号，在字符类符号(括号[])之内与之外是不同的！ 在 [] 内代表『反向选择』，在 [] 之外则代表定位在行首的意义！

 

那如果我想要找出来，行尾结束为小数点 (.) 的那一行：


[root@www ~]# grep -n '\.$' regular_express.txt
1:"Open Source" is a good mechanism to develop programs.
2:apple is my favorite food.
3:Football game is not use feet only.
4:this dress doesn't fit me.
10:motorcycle is cheap than car.
11:This window is clear.
12:the symbol '*' is represented as start.
15:You are the best is mean you are the no. 1.
16:The world <Happy> is the same with "glad".
17:I like dog.
18:google is the best tools for search keyword.
20:go! go! Let's go.



特别注意到，因为小数点具有其他意义(底下会介绍)，所以必须要使用转义字符(\)来加以解除其特殊意义！

 

找出空白行：

[root@www ~]# grep -n '^$' regular_express.txt
22:

因为只有行首跟行尾 (^$)，所以，这样就可以找出空白行啦！

 

任意一个字节 . 与重复字节 *
这两个符号在正则表达式的意义如下：

. (小数点)：代表『一定有一个任意字节』的意思；
* (星号)：代表『重复前一个字符， 0 到无穷多次』的意思，为组合形态

假设我需要找出 g??d 的字串，亦即共有四个字节， 起头是 g 而结束是 d ，我可以这样做：

[root@www ~]# grep -n 'g..d' regular_express.txt
1:"Open Source" is a good mechanism to develop programs.
9:Oh! The soup taste good.
16:The world <Happy> is the same with "glad".

因为强调 g 与 d 之间一定要存在两个字节，因此，第 13 行的 god 与第 14 行的 gd 就不会被列出来啦！

 

如果我想要列出有 oo, ooo, oooo 等等的数据， 也就是说，至少要有两个(含) o 以上，该如何是好？

因为 * 代表的是『重复 0 个或多个前面的 RE 字符』的意义， 因此，『o*』代表的是：『拥有空字节或一个 o 以上的字节』，因此，『 grep -n 'o*' regular_express.txt 』将会把所有的数据都列印出来终端上！

当我们需要『至少两个 o 以上的字串』时，就需要 ooo* ，亦即是：
复制代码

[root@www ~]# grep -n 'ooo*' regular_express.txt
1:"Open Source" is a good mechanism to develop programs.
2:apple is my favorite food.
3:Football game is not use feet only.
9:Oh! The soup taste good.
18:google is the best tools for search keyword.
19:goooooogle yes!



如果我想要字串开头与结尾都是 g，但是两个 g 之间仅能存在至少一个 o ，亦即是 gog, goog, gooog.... 等等，那该如何？

[root@www ~]# grep -n 'goo*g' regular_express.txt
18:google is the best tools for search keyword.
19:goooooogle yes!

 

如果我想要找出 g 开头与 g 结尾的行，当中的字符可有可无

[root@www ~]# grep -n 'g.*g' regular_express.txt
1:"Open Source" is a good mechanism to develop programs.
14:The gd software is a library for drafting programs.
18:google is the best tools for search keyword.
19:goooooogle yes!
20:go! go! Let's go.


因为是代表 g 开头与 g 结尾，中间任意字节均可接受，所以，第 1, 14, 20 行是可接受的喔！ 这个 .* 的 RE 表示任意字符是很常见的.

 

如果我想要找出『任意数字』的行？因为仅有数字，所以就成为：

[root@www ~]# grep -n '[0-9][0-9]*' regular_express.txt
5:However, this dress is about $ 3183 dollars.
15:You are the best is mean you are the no. 1.

 

 

限定连续 RE 字符范围 {}
我们可以利用 . 与 RE 字符及 * 来配置 0 个到无限多个重复字节， 那如果我想要限制一个范围区间内的重复字节数呢？

举例来说，我想要找出两个到五个 o 的连续字串，该如何作？这时候就得要使用到限定范围的字符 {} 了。 但因为 { 与 } 的符号在 shell 是有特殊意义的，因此， 我们必须要使用字符   \ 来让他失去特殊意义才行。 至於 {} 的语法是这样的，假设我要找到两个 o 的字串，可以是：
复制代码

[root@www ~]# grep -n 'o\{2\}' regular_express.txt
1:"Open Source" is a good mechanism to develop programs.
2:apple is my favorite food.
3:Football game is not use feet only.
9:Oh! The soup taste good.
18:google is the best tools for search ke
19:goooooogle yes!

复制代码

 

假设我们要找出 g 后面接 2 到 5 个 o ，然后再接一个 g 的字串，他会是这样：

[root@www ~]# grep -n 'go\{2,5\}g' regular_express.txt
18:google is the best tools for search keyword.

 

如果我想要的是 2 个 o 以上的 goooo....g 呢？除了可以是 gooo*g ，也可以是：

[root@www ~]# grep -n 'go\{2,\}g' regular_express.txt
18:google is the best tools for search keyword.
19:goooooogle yes!

 

扩展grep(grep -E 或者 egrep)：
使用扩展grep的主要好处是增加了额外的正则表达式元字符集。

 

打印所有包含NW或EA的行。如果不是使用egrep，而是grep，将不会有结果查出。

    # egrep 'NW|EA' testfile     
    northwest       NW      Charles Main        3.0     .98     3       34
    eastern         EA      TB Savage           4.4     .84     5       20

 

对于标准grep，如果在扩展元字符前面加\，grep会自动启用扩展选项-E。

#grep 'NW\|EA' testfile
northwest       NW      Charles Main        3.0     .98     3       34
eastern         EA      TB Savage           4.4     .84     5       20

 

搜索所有包含一个或多个3的行。
复制代码

# egrep '3+' testfile
# grep -E '3+' testfile
# grep '3\+' testfile        
#这3条命令将会
northwest       NW      Charles Main          3.0     .98     3       34
western         WE      Sharon Gray           5.3     .97     5       23
northeast       NE      AM Main Jr.           5.1     .94     3       13
central         CT      Ann Stephens          5.7     .94     5       13

复制代码

 

搜索所有包含0个或1个小数点字符的行。
    
复制代码

# egrep '2\.?[0-9]' testfile 
# grep -E '2\.?[0-9]' testfile
# grep '2\.\?[0-9]' testfile 
#首先含有2字符，其后紧跟着0个或1个点，后面再是0和9之间的数字。
western         WE       Sharon Gray          5.3     .97     5       23
southwest       SW      Lewis Dalsass         2.7     .8      2       18
eastern         EA       TB Savage             4.4     .84     5       20

复制代码

 

搜索一个或者多个连续的no的行。
    

# egrep '(no)+' testfile
# grep -E '(no)+' testfile
# grep '\(no\)\+' testfile   #3个命令返回相同结果，
northwest       NW      Charles Main        3.0     .98     3       34
northeast       NE       AM Main Jr.        5.1     .94     3       13
north           NO      Margot Weber        4.5     .89     5       9

 

不使用正则表达式

fgrep 查询速度比grep命令快，但是不够灵活：它只能找固定的文本，而不是规则表达式。

如果你想在一个文件或者输出中找到包含星号字符的行

fgrep  '*' /etc/profile
for i in /etc/profile.d/*.sh ; do

或
grep -F '*' /etc/profile
for i in /etc/profile.d/*.sh ; do

 

参考 http://vbird.dic.ksu.edu.tw/linux_basic/0330regularex_2.php

       http://www.cnblogs.com/stephen-liu74/archive/2011/11/14/2243694.html


=========================

找出文件夹下包含 “aaa” 同时不包含 “bbb”的文件，然后把他们重新生成一下。要求只能用一行命令。

我对Linux 是个白痴，工作了之后才开始接触的，会用的命令只有那几个常用的。这个问题对我来说就有点难度，我只是大概知道查找文件用 grep ，其他的就不知道了。不过没关系，用Google ，查找到 grep 的完整用法：

1、grep -l ‘boss’ * 显示所有包含boss的文件名。
2、grep -n ‘boss’ file在匹配行之前加行号。
3、grep -i ‘boss’ file显示匹配行，boss不区分大小写。
4、grep -v ‘boss’ file显示所有不匹配行。
5、grep -q ‘boss’ file找到匹配行，但不显示，但可以检查grep的退出状态。（0为匹配成功）
6、grep -c ‘boss’ file只显示匹配行数（包括0）。
7、grep “$boss” file扩展变量boss的值再执行命令。
8、ps -ef|grep “^*user1″ 搜索user1的命令，即使它前面有零个或多个空格。
9、ps -e|grep -E ‘grant_server|commsvr|tcpsvr|dainfo’ 查找多个字符串的匹配（grep -E相当于egrep）


了解了grep的参数之后，问题就解决了一半了，因为可以搜索出符合条件的文件了。不过光有grep 还是不行，因为要把搜索出来的文件名作为参数传给 generate 命令。OK，接下来该管道符出场了。

即使是像我这样对linux只是有一点了解的人也经常用到管道符，比如“|”，示例： ls -a | more 。但是对于管道符的具体意义和它做了什么我就不知道了，没关系，Google 一下，找到一些资料：

利用Linux所提供的管道符“|”将两个命令隔开，管道符左边命令的输出就会作为管道符右边命令的输入。连续使用管道意味着第一个命令的输出会作为第二个命令的输入，第二个命令的输出又会作为第三个命令的输入，依此类推。

所以查找的时候可以这样写：

grep -rl “aaa” * | grep -v “bbb”

这样右边的命令就可以从前面的结果中筛选了。然后还有 generate 命令，因为生成文件的命令格式是这样的：

generate 文件名

不过如果直接使用 generate grep -rl “aaa” * | grep -v “bbb” 的话会出错，因为命令会从左向右执行，这条命令就会把grep作为一个文件名来看待。怎么办呢？这个时候就要使用 ・ (键盘上数字键1 旁边的那个符号，和“~”在一个按键上)来做命令替换了，用 ・ 把后面的 grep 命令包起来就好了，这样：

generate ・grep -rl “aaa” * | grep -v “bbb”・

然后就搞定了。

 ==================

  linux grep命令

  http://www.cnblogs.com/end/archive/2012/02/21/2360965.html

1.作用
Linux系统中grep命令是一种强大的文本搜索工具，它能使用正则表达式搜索文本，并把匹 配的行打印出来。grep全称是Global Regular Expression Print，表示全局正则表达式版本，它的使用权限是所有用户。

2.格式
grep [options]

3.主要参数
[options]主要参数：
－c：只输出匹配行的计数。
－I：不区分大 小写(只适用于单字符)。
－h：查询多文件时不显示文件名。
－l：查询多文件时只输出包含匹配字符的文件名。
－n：显示匹配行及 行号。
－s：不显示不存在或无匹配文本的错误信息。
－v：显示不包含匹配文本的所有行。
pattern正则表达式主要参数：
\： 忽略正则表达式中特殊字符的原有含义。
^：匹配正则表达式的开始行。
$: 匹配正则表达式的结束行。
\<：从匹配正则表达 式的行开始。
\>：到匹配正则表达式的行结束。
[ ]：单个字符，如[A]即A符合要求 。
[ - ]：范围，如[A-Z]，即A、B、C一直到Z都符合要求 。
。：所有的单个字符。
* ：有字符，长度可以为0。

4.grep命令使用简单实例
$ grep ‘test’ d*
显示所有以d开头的文件中包含 test的行。
$ grep ‘test’ aa bb cc
显示在aa，bb，cc文件中匹配test的行。
$ grep ‘[a-z]\{5\}’ aa
显示所有包含每个字符串至少有5个连续小写字符的字符串的行。
$ grep ‘w\(es\)t.*\1′ aa
如果west被匹配，则es就被存储到内存中，并标记为1，然后搜索任意个字符(.*)，这些字符后面紧跟着 另外一个es(\1)，找到就显示该行。如果用egrep或grep -E，就不用”\”号进行转义，直接写成’w(es)t.*\1′就可以了。

5.grep命令使用复杂实例
假设您正在’/usr/src/Linux/Doc’目录下搜索带字符 串’magic’的文件：
$ grep magic /usr/src/Linux/Doc/*
sysrq.txt:* How do I enable the magic SysRQ key?
sysrq.txt:* How do I use the magic SysRQ key?
其中文件’sysrp.txt’包含该字符串，讨论的是 SysRQ 的功能。
默认情况下，’grep’只搜索当前目录。如果 此目录下有许多子目录，’grep’会以如下形式列出：
grep: sound: Is a directory
这可能会使’grep’ 的输出难于阅读。这里有两种解决的办法：
明确要求搜索子目录：grep -r
或忽略子目录：grep -d skip
如果有很多 输出时，您可以通过管道将其转到’less’上阅读：
$ grep magic /usr/src/Linux/Documentation/* | less
这样，您就可以更方便地阅读。

有一点要注意，您必需提供一个文件过滤方式(搜索全部文件的话用 *)。如果您忘了，’grep’会一直等着，直到该程序被中断。如果您遇到了这样的情况，按 <CTRL c> ，然后再试。

下面还有一些有意思的命令行参数：
grep -i pattern files ：不区分大小写地搜索。默认情况区分大小写，
grep -l pattern files ：只列出匹配的文件名，
grep -L pattern files ：列出不匹配的文件名，
grep -w pattern files ：只匹配整个单词，而不是字符串的一部分(如匹配’magic’，而不是’magical’)，
grep -C number pattern files ：匹配的上下文分别显示[number]行，
grep pattern1 | pattern2 files ：显示匹配 pattern1 或 pattern2 的行，
grep pattern1 files | grep pattern2 ：显示既匹配 pattern1 又匹配 pattern2 的行。

grep -n pattern files  即可显示行号信息

grep -c pattern files  即可查找总行数

这里还有些用于搜索的特殊符号：
\< 和 \> 分别标注单词的开始与结尾。
例如：
grep man * 会匹配 ‘Batman’、’manic’、’man’等，
grep ‘\<man’ * 匹配’manic’和’man’，但不是’Batman’，
grep ‘\<man\>’ 只匹配’man’，而不是’Batman’或’manic’等其他的字符串。
‘^’：指匹配的字符串在行首，
‘$’：指匹配的字符串在行 尾，



Grep 命令 用法大全
1、 参数：
-I ：忽略大小写
-c ：打印匹配的行数
-l ：从多个文件中查找包含匹配项
-v ：查找不包含匹配项的行
-n：打印包含匹配项的行和行标

2、RE（正则表达式）
\ 忽略正则表达式中特殊字符的原有含义
^ 匹配正则表达式的开始行
$ 匹配正则表达式的结束行
\< 从匹配正则表达式的行开始
\> 到匹配正则表达式的行结束
[ ] 单个字符；如[A] 即A符合要求
[ - ] 范围 ；如[A-Z]即A，B，C一直到Z都符合要求
. 所有的单个字符
* 所有字符，长度可以为0

3、举例
# ps -ef | grep in.telnetd
root 19955 181 0 13:43:53 ? 0:00 in.telnetd

# more size.txt size文件的内容
b124230
b034325
a081016
m7187998
m7282064
a022021
a061048
m9324822
b103303
a013386
b044525
m8987131
B081016
M45678
B103303
BADc2345

# more size.txt | grep '[a-b]' 范围 ；如[A-Z]即A，B，C一直到Z都符合要求
b124230
b034325
a081016
a022021
a061048
b103303
a013386
b044525
# more size.txt | grep '[a-b]'*
b124230
b034325
a081016
m7187998
m7282064
a022021
a061048
m9324822
b103303
a013386
b044525
m8987131
B081016
M45678
B103303
BADc2345

# more size.txt | grep 'b' 单个字符；如[A] 即A符合要求
b124230
b034325
b103303
b044525
# more size.txt | grep '[bB]'
b124230
b034325
b103303
b044525
B081016
B103303
BADc2345

# grep 'root' /etc/group
root::0:root
bin::2:root,bin,daemon
sys::3:root,bin,sys,adm
adm::4:root,adm,daemon
uucp::5:root,uucp
mail::6:root
tty::7:root,tty,adm
lp::8:root,lp,adm
nuucp::9:root,nuucp
daemon::12:root,daemon

# grep '^root' /etc/group 匹配正则表达式的开始行
root::0:root

# grep 'uucp' /etc/group
uucp::5:root,uucp
nuucp::9:root,nuucp

# grep '\<uucp' /etc/group
uucp::5:root,uucp

# grep 'root$' /etc/group 匹配正则表达式的结束行
root::0:root
mail::6:root

# more size.txt | grep -i 'b1..*3' -i ：忽略大小写

b124230
b103303
B103303

# more size.txt | grep -iv 'b1..*3' -v ：查找不包含匹配项的行

b034325
a081016
m7187998
m7282064
a022021
a061048
m9324822
a013386
b044525
m8987131
B081016
M45678
BADc2345

# more size.txt | grep -in 'b1..*3'
1:b124230
9:b103303
15:B103303

# grep '$' /etc/init.d/nfs.server | wc -l
128
# grep '\$' /etc/init.d/nfs.server | wc Cl 忽略正则表达式中特殊字符的原有含义

15
# grep '\$' /etc/init.d/nfs.server
case "$1" in
>/tmp/sharetab.$$
[ "x$fstype" != xnfs ] &&
echo "$path\t$res\t$fstype\t$opts\t$desc"
>>/tmp/sharetab.$$
/usr/bin/touch -r /etc/dfs/sharetab /tmp/sharetab.$$
/usr/bin/mv -f /tmp/sharetab.$$ /etc/dfs/sharetab
if [ -f /etc/dfs/dfstab ] && /usr/bin/egrep -v '^[ ]*(#|$)'
if [ $startnfsd -eq 0 -a -f /etc/rmmount.conf ] &&
if [ $startnfsd -ne 0 ]; then
elif [ ! -n "$_INIT_RUN_LEVEL" ]; then
while [ $wtime -gt 0 ]; do
wtime=`expr $wtime - 1`
if [ $wtime -eq 0 ]; then
echo "Usage: $0 { start | stop }"

# more size.txt

the test file
their are files
The end

# grep 'the' size.txt
the test file
their are files

# grep '\<the' size.txt
the test file
their are files

# grep 'the\>' size.txt
the test file

# grep '\<the\>' size.txt
the test file

# grep '\<[Tt]he\>' size.txt
the test file

==================================================================

1,简介
使用正则表达式的一个多用途文本搜索工具.这个php?name=%C3%FC%C1%EE" onclick="tagshow(event)" class="t_tag">命令本来是ed行编辑器中的一个php?name=%C3%FC%C1%EE" onclick="tagshow(event)" class="t_tag">命令/过滤器:
        g/re/p -- global - regular expression - print.
基本格式
grep pattern [file...]
(1)grep 搜索字符串 [filename]
(2)grep 正则表达式 [filename]
在文件中搜索所有 pattern 出现的位置, pattern 既可以是要搜索的字符串,也可以是一个正则表达式.
注意：在输入要搜索的字符串时最好使用双引号/而在模式匹配使用正则表达式时，注意使用单引号

2,grep的选项
    -c 只输出匹配行的计数
    -i 不区分大小写（用于单字符）
    -n 显示匹配的行号
    -v 不显示不包含匹配文本的所以有行
    -s 不显示错误信息
    -E 使用扩展正则表达式
    更多的选项请查看：man grep

3,常用grep实例

(1)多个文件查询
    grep "sort" *.doc       #见文件名的匹配

(2)行匹配:输出匹配行的计数
    grep -c "48" data.doc   #输出文档中含有48字符的行数

(3)显示匹配行和行数
    grep -n "48" data.doc       #显示所有匹配48的行和行号

(4)显示非匹配的行
    grep -vn "48" data.doc      #输出所有不包含48的行

(4)显示非匹配的行
    grep -vn "48" data.doc      #输出所有不包含48的行

(5)大小写敏感
    grep -i "ab" data.doc       #输出所有含有ab或Ab的字符串的行

4, 正则表达式的应用

(1)正则表达式的应用 (注意：最好把正则表达式用单引号括起来)
    grep '[239].' data.doc      #输出所有含有以2,3或9开头的，并且是两个数字的行

(2)不匹配测试
    grep '^[^48]' data.doc      #不匹配行首是48的行

(3)使用扩展模式匹配
    grep -E '219|216' data.doc

(4) ...
    这需要在实践中不断应用和总结，熟练掌握正则表达式。

5, 使用类名
可以使用国际模式匹配的类名：
[[:upper:]]   [A-Z]
[[:lower:]]   [a-z]
[[:digit:]]   [0-9]
[[:alnum:]]   [0-9a-zA-Z]
[[:space:]]   空格或tab
[[:alpha:]]   [a-zA-Z]

(1)使用
    grep '5[[:upper:]][[:upper:]]' data.doc     #查询以5开头以两个大写字母结尾的行 

=======================

pipe

 linux shell 管道命令(pipe)使用及与shell重定向区别

http://www.cnblogs.com/chengmo/archive/2010/10/21/1856577.html

看了前面一节：linux shell数据重定向（输入重定向与输出重定向）详细分析 估计还有一些朋友是头晕晕的，好复杂的重定向了。这次我们看下管道命令了。shell管道，可以说用法就简单多了。

 

管道命令操作符是：”|”,它仅能处理经由前面一个指令传出的正确输出信息，也就是 standard output 的信息，对于 stdandard
error 信息没有直接处理能力。然后，传递给下一个命令，作为标准的输入 standard input.

 

    管道命令使用说明： 

    先看下下面图：

    image

    command1正确输出，作为command2的输入 然后comand2的输出作为，comand3的输入 ，comand3输出就会直接显示在屏幕上面了。

    通过管道之后：comand1,comand2的正确输出不显示在屏幕上面

    注意：

    1、管道命令只处理前一个命令正确输出，不处理错误输出

    2、管道命令右边命令，必须能够接收标准输入流命令才行。

    实例：
    	
    [chengmo@centos5 shell]$ cat test.sh | grep -n 'echo'
    5:    echo "very good!";
    7:    echo "good!";
    9:    echo "pass!";
    11:    echo "no pass!";
    #读出test.sh文件内容，通过管道转发给grep 作为输入内容
     
    [chengmo@centos5 shell]$ cat test.sh test1.sh | grep -n 'echo'
    cat: test1.sh: 没有那个文件或目录
    5:    echo "very good!";
    7:    echo "good!";
    9:    echo "pass!";
    11:    echo "no pass!";
    #cat test1.sh不存在，错误输出打印到屏幕，正确输出通过管道发送给grep 
     
     
    [chengmo@centos5 shell]$ cat test.sh test1.sh 2>/dev/null | grep -n 'echo' 
    5:    echo "very good!";
    7:    echo "good!";
    9:    echo "pass!";
    11:    echo "no pass!";
    #将test1.sh 没有找到错误输出重定向输出给/dev/null 文件，正确输出通过管道发送给grep
     
     
    [chengmo@centos5 shell]$ cat test.sh | ls
    catfile      httprequest.txt  secure  test            testfdread.sh  testpipe.sh    testsh.sh      testwhile2.sh
    envcron.txt  python           sh      testcase.sh     testfor2.sh    testselect.sh  test.txt       text.txt
    env.txt      release          sms     testcronenv.sh  testfor.sh     test.sh        testwhile1.sh
    #读取test.sh内容，通过管道发送给ls命令，由于ls 不支持标准输入，因此数据被丢弃

     

    这里实例就是对上面2点注意的验证。作用接收标准输入的命令才可以用作管道右边。否则传递过程中数据会抛弃。 常用来作为接收数据管道命令有：sed,awk,cut,head,top,less,more,wc,join,sort,split 等等，都是些文本处理命令。

    管道命令与重定向区别 

    区别是：

    1、左边的命令应该有标准输出 | 右边的命令应该接受标准输入
       左边的命令应该有标准输出 > 右边只能是文件
       左边的命令应该需要标准输入 < 右边只能是文件

     

    2、管道触发两个子进程执行"|"两边的程序；而重定向是在一个进程内执行

    这些都是网上总结很多的，其实只要多加清楚用法，也一定有自己的一份不同描述。

    实例:
    	
    #可以相互转换情况
    #输入重定向
     
    [chengmo@centos5 shell]$ cat test.sh| grep -n 'echo'
    5:    echo "very good!";
    7:    echo "good!";
    9:    echo "pass!";
    11:    echo "no pass!";
    #"|"管道两边都必须是shell命令
     
     
    [chengmo@centos5 shell]$ grep -n 'echo' <test.sh    
    5:    echo "very good!";
    7:    echo "good!";
    9:    echo "pass!";
    11:    echo "no pass!";
    #"重定向"符号，右边只能是文件（普通文件，文件描述符，文件设备）
     
     
    [chengmo@centos5 shell]$ mail -s 'test' 8292669@qq.com <test.sh
    [chengmo@centos5 shell]$ cat test.sh|mail -s 'test' 8292669@qq.com
    #以上2个也相同，将test.sh内容发送到指定邮箱。
     
     
    [chengmo@centos5 shell]$ (sed -n '1,$p'|grep -n 'echo')<test.sh 
    5:    echo "very good!";
    7:    echo "good!";
    9:    echo "pass!";
    11:    echo "no pass!";
    #这个脚本比较有意思了。由于前面是管道，后面需要把test.sh内容重定向到 sed ，然后sed输出通过管道，输入给grep.需要将前面用"()"运算符括起来。在单括号内的命令，可以把它们看作一个象一个命令样。如果不加括号test.sh就是grep 的输入了。
     
     
    #上面一个等同于这个
    [chengmo@centos5 shell]$ sed -n '1,$p'<test.sh | grep -n 'echo'
    5:    echo "very good!";
    7:    echo "good!";
    9:    echo "pass!";
    11:    echo "no pass!";
     
    #重定向运算符，在shell命令解析前，首先检查的（一个命令，执行前一定检查好它的输入，输出，也就是0,1,2 设备是否准备好），所以优先级会最高
     
     
    [chengmo@centos5 shell]$ sed -n '1,10p'<test.sh | grep -n 'echo' <testsh.sh
    10:echo $total;
    18:echo $total;
    21:     echo "ok";
    #哈哈，这个grep又接受管道输入，又有testsh.sh输入，那是不是2个都接收呢。刚才说了"<"运算符会优先，管道还没有发送数据前，grep绑定了testsh.sh输入，这样sed命令输出就被抛弃了。这里一定要小心使用
     
    #输出重定向
     
    [chengmo@centos5 shell]$ cat test.sh>test.txt
    [chengmo@centos5 shell] cat test.sh|tee test.txt &>/dev/null
    #通过管道实现将结果存入文件,还需要借助命令tee，它会把管道过来标准输入写入文件test.txt ,然后将标准输入复制到标准输出(stdout),所以重定向到/dev/null 不显示输出
    #">"输出重定向，往往在命令最右边，接收左边命令的，输出结果，重定向到指定文件。也可以用到命令中间。
     
     
    [chengmo@centos5 shell]$ ls test.sh test1.sh testsh.sh 2>err.txt | grep 'test'
    test.sh
    testsh.sh
    #目录下面有：test,testsh文件，test1.sh不存在，因此将ls 命令错误输出输入到err.txt 正确输出，还会通过管道发送到grep命令。
    [chengmo@centos5 shell]$ ls test.sh test1.sh testsh.sh &>err.txt | grep 'test'
    #这次打印结果是空，&代表正确与错误输出 都输入给err.txt，通过管道继续往下面传递数据为空,所以没有什么显示的
     
    #同样">"输出重定向符，优先级也是先解析，当一个命令有这个字符，它就会与左边命令标准输出绑定。准备好了这些，就等待命令执行输出数据，它就开始接收

     

    再概括下：

    从上面例子可以看，重定向与管道在使用时候很多时候可以通用，其实，在shell里面，经常是【条条大路通罗马】的。一般如果是命令间传递参数，还是管道的好，如果处理输出结果需要重定向到文件，还是用重定向输出比较好。

    命令执行顺序可以看下：Linux Shell 通配符、元字符、转义符使用实例介绍

    shell脚本接收管道输入 

    有意思的问题：

    既然作用管道接收命令，需要可以接收标准的输入，那么我们shell脚本是否可以开发出这样的基本程序呢？（大家经常看到的，都是一些系统的命令作为管道接收方）

    实例（testpipe.sh)：
   
    	
    #!/bin/sh
      
     if [ $# -gt 0 ];then
         exec 0<$1;
    #判断是否传入参数：文件名，如果传入，将该文件绑定到标准输入
     fi
      
     while read line
     do
         echo $line;
     done<&0;
    #通过标准输入循环读取内容
     exec 0&-;
    #解除标准输入绑定

    运行结果：
    [chengmo@centos5 shell]$ cat testpipe.txt
    1,t,est pipe
    2,t,est pipe
    3,t,est pipe
    4,t,est pipe
    #testpipe.txt 只是需要读取的测试文本
     
    [chengmo@centos5 shell]$ cat testpipe.txt | sh testpipe.sh
    1,t,est pipe
    2,t,est pipe
    3,t,est pipe
    4,t,est pipe
    #通过cat 读取 testpipe.txt 发送给testpipe.sh 标准输入
     
    [chengmo@centos5 shell]$ sh testpipe.sh testpipe.txt      
    1,t,est pipe
    2,t,est pipe
    3,t,est pipe
    4,t,est pipe
    #testpipe.sh 通过出入文件名读取文件内容

分类: linux


========================

 linux管道命令学习（一）

http://www.cnblogs.com/mrzero/p/3985302.html

继续看鸟哥私房菜，看一直很想弄懂的管道命令(pipe)。第一次知道管道这个词还是在学django的时候，模板里的过滤器很像这里的管道。管道就是将输出在标准输出中的信息一次次处理最终打印在标准输出中，所以管道命令必须是接受标准输出的命令，cp mv ls都不是管道命令。
好用的less和tail
less

如ls -al /etc | less就能用类似vi的方式浏览在屏幕上打印的内容了。还能用vi里的查找命令/、?，可以避免滚屏，非常好用。
tail

    tail filename输出文件最后10行
    tail -n 5 filename输出文件最后5行
    tail -F filename监视文件的改变，一有变化就显示出来

在分析error log的时候非常有用，可以查看最近的错误信息。
选取命令cut和grep
cut

cut针对的是输出的每一行，解释两个命令：

    echo $PATH | cut -d ':' -f 5
    -d 选项后面紧跟分隔符，-f表示取第5段
    export | cut -c 12-
    -c 选项表示选取的字符数，从12到结尾，也可是类似12-15这样

grep

grep真是神一般的命令，可以配合ps aux找到想要的进程。
参数

    -c计算找到的被查找字符串的次数
    -i忽略大小写
    -v输出查找结果的补集
    例如last | grep -v 'root'找出非root的登陆

=============================










