
设计模式的分类

总体来说设计模式分为三大类：

创建型模式，共五种：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。

结构型模式，共七种：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。

行为型模式，共十一种：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。


http://www.cnblogs.com/maowang1991/archive/2013/04/15/3023236.html

http://www.cnblogs.com/Coda/p/4283025.html

http://blog.csdn.net/top_code/article/details/8469297

http://www.cnblogs.com/moonz-wu/archive/2011/01/11/1932473.html

Java设计模式四: 原型模式(Prototype Pattern)
http://www.cnblogs.com/itTeacher/archive/2012/12/02/2797857.html

http://www.cnblogs.com/itTeacher/archive/2012/11/30/2796570.html

======================

http://blog.csdn.net/zhangerqing/article/details/8194653/

举例如下：（我们举一个发送邮件和短信的例子）

首先，创建二者的共同接口：
[java] view plain copy

    public interface Sender {  
        public void Send();  
    }  

其次，创建实现类：
[java] view plain copy

    public class MailSender implements Sender {  
        @Override  
        public void Send() {  
            System.out.println("this is mailsender!");  
        }  
    }  

[java] view plain copy

    public class SmsSender implements Sender {  
      
        @Override  
        public void Send() {  
            System.out.println("this is sms sender!");  
        }  
    }  

最后，建工厂类：
[java] view plain copy

    public class SendFactory {  
      
        public Sender produce(String type) {  
            if ("mail".equals(type)) {  
                return new MailSender();  
            } else if ("sms".equals(type)) {  
                return new SmsSender();  
            } else {  
                System.out.println("请输入正确的类型!");  
                return null;  
            }  
        }  
    }  

我们来测试下：
[java] view plain copy

    public class FactoryTest {  
      
        public static void main(String[] args) {  
            SendFactory factory = new SendFactory();  
            Sender sender = factory.produce("sms");  
            sender.Send();  
        }  
    }  

输出：this is sms sender!

=====================

 JAVA设计模式之工厂模式(简单工厂模式+工厂方法模式)
标签： 设计模式工厂模式java设计模式java
2014-04-07 17:36 126721人阅读 评论(23) 收藏 举报
分类：
设计模式（20）

 在面向对象编程中, 最通常的方法是一个new操作符产生一个对象实例,new操作符就是用来构造对象实例的。但是在一些情况下, new操作符直接生成对象会带来一些问题。举例来说, 许多类型对象的创造需要一系列的步骤: 你可能需要计算或取得对象的初始设置; 选择生成哪个子对象实例; 或在生成你需要的对象之前必须先生成一些辅助功能的对象。 在这些情况,新对象的建立就是一个 “过程”，不仅是一个操作，像一部大机器中的一个齿轮传动。

模式的问题：你如何能轻松方便地构造对象实例，而不必关心构造对象实例的细节和复杂过程呢？

解决方案：建立一个工厂来创建对象

实现：

一、引言
    1）还没有工厂时代：假如还没有工业革命，如果一个客户要一款宝马车,一般的做法是客户去创建一款宝马车，然后拿来用。
    2）简单工厂模式：后来出现工业革命。用户不用去创建宝马车。因为客户有一个工厂来帮他创建宝马.想要什么车，这个工厂就可以建。比如想要320i系列车。工厂就创建这个系列的车。即工厂可以创建产品。
    3）工厂方法模式时代：为了满足客户，宝马车系列越来越多，如320i，523i,30li等系列一个工厂无法创建所有的宝马系列。于是由单独分出来多个具体的工厂。每个具体工厂创建一种系列。即具体工厂类只能创建一个具体产品。但是宝马工厂还是个抽象。你需要指定某个具体的工厂才能生产车出来。

   4）抽象工厂模式时代：随着客户的要求越来越高，宝马车必须配置空调。于是这个工厂开始生产宝马车和需要的空调。

   最终是客户只要对宝马的销售员说：我要523i空调车，销售员就直接给他523i空调车了。而不用自己去创建523i空调车宝马车.

   这就是工厂模式。

二、分类 
        工厂模式主要是为创建对象提供过渡接口，以便将创建对象的具体过程屏蔽隔离起来，达到提高灵活性的目的。 
工厂模式可以分为三类： 

1）简单工厂模式（Simple Factory） 
2）工厂方法模式（Factory Method） 
3）抽象工厂模式（Abstract Factory） 

 这三种模式从上到下逐步抽象，并且更具一般性。 
        GOF在《设计模式》一书中将工厂模式分为两类：工厂方法模式（Factory Method）与抽象工厂模式（Abstract Factory）。

        将简单工厂模式（Simple Factory）看为工厂方法模式的一种特例，两者归为一类。 

三、区别 
工厂方法模式：
一个抽象产品类，可以派生出多个具体产品类。   
一个抽象工厂类，可以派生出多个具体工厂类。   
每个具体工厂类只能创建一个具体产品类的实例。
抽象工厂模式：
多个抽象产品类，每个抽象产品类可以派生出多个具体产品类。   
一个抽象工厂类，可以派生出多个具体工厂类。   
每个具体工厂类可以创建多个具体产品类的实例。   
区别：
工厂方法模式只有一个抽象产品类，而抽象工厂模式有多个。   
工厂方法模式的具体工厂类只能创建一个具体产品类的实例，而抽象工厂模式可以创建多个。
两者皆可。 

 四、简单工厂模式 
建立一个工厂（一个函数或一个类方法）来制造新的对象。
分布说明引子：从无到有。客户自己创建宝马车，然后拿来用。

 

 
[java] view plain copy
print?

    public class BMW320 {  
        public BMW320(){  
            System.out.println("制造-->BMW320");  
        }  
    }  
      
    public class BMW523 {  
        public BMW523(){  
            System.out.println("制造-->BMW523");  
        }  
    }  
      
    public class Customer {  
        public static void main(String[] args) {  
            BMW320 bmw320 = new BMW320();  
            BMW523 bmw523 = new BMW523();  
        }  
    }  

客户需要知道怎么去创建一款车,客户和车就紧密耦合在一起了.为了降低耦合,就出现了工厂类,把创建宝马的操作细节都放到了工厂里面去,客户直接使用工厂的创建工厂方法,传入想要的宝马车型号就行了,而不必去知道创建的细节.这就是工业革命了：简单工厂模式

即我们建立一个工厂类方法来制造新的对象。如图：


产品类：
[java] view plain copy
print?

    abstract class BMW {  
        public BMW(){  
              
        }  
    }  
      
    public class BMW320 extends BMW {  
        public BMW320() {  
            System.out.println("制造-->BMW320");  
        }  
    }  
    public class BMW523 extends BMW{  
        public BMW523(){  
            System.out.println("制造-->BMW523");  
        }  
    }  

工厂类：
[java] view plain copy
print?

    public class Factory {  
        public BMW createBMW(int type) {  
            switch (type) {  
              
            case 320:  
                return new BMW320();  
      
            case 523:  
                return new BMW523();  
      
            default:  
                break;  
            }  
            return null;  
        }  
    }  


客户类：
[java] view plain copy
print?

    public class Customer {  
        public static void main(String[] args) {  
            Factory factory = new Factory();  
            BMW bmw320 = factory.createBMW(320);  
            BMW bmw523 = factory.createBMW(523);  
        }  
    }  

   简单工厂模式又称静态工厂方法模式。重命名上就可以看出这个模式一定很简单。它存在的目的很简单：定义一个用于创建对象的接口。 
      先来看看它的组成： 
         1) 工厂类角色：这是本模式的核心，含有一定的商业逻辑和判断逻辑，用来创建产品
         2) 抽象产品角色：它一般是具体产品继承的父类或者实现的接口。         
         3) 具体产品角色：工厂类所创建的对象就是此角色的实例。在Java中由一个具体类实现。 
        
        下面我们从开闭原则（对扩展开放；对修改封闭）上来分析下简单工厂模式。当客户不再满足现有的车型号的时候，想要一种速度快的新型车，只要这种车符合抽象产品制定的合同，那么只要通知工厂类知道就可以被客户使用了。所以对产品部分来说，它是符合开闭原则的；但是工厂部分好像不太理想，因为每增加一种新型车，都要在工厂类中增加相应的创建业务逻辑（createBMW(int type)方法需要新增case），这显然是违背开闭原则的。可想而知对于新产品的加入，工厂类是很被动的。对于这样的工厂类，我们称它为全能类或者上帝类。 
        我们举的例子是最简单的情况，而在实际应用中，很可能产品是一个多层次的树状结构。由于简单工厂模式中只有一个工厂类来对应这些产品，所以这可能会把我们的上帝累坏了，也累坏了我们这些程序员。
        于是工厂方法模式作为救世主出现了。 工厂类定义成了接口,而每新增的车种类型,就增加该车种类型对应工厂类的实现,这样工厂的设计就可以扩展了,而不必去修改原来的代码。
五、工厂方法模式 
        工厂方法模式去掉了简单工厂模式中工厂方法的静态属性，使得它可以被子类继承。这样在简单工厂模式里集中在工厂方法上的压力可以由工厂方法模式里不同的工厂子类来分担。 
工厂方法模式组成： 
       1)抽象工厂角色： 这是工厂方法模式的核心，它与应用程序无关。是具体工厂角色必须实现的接口或者必须继承的父类。在java中它由抽象类或者接口来实现。 
       2)具体工厂角色：它含有和具体业务逻辑有关的代码。由应用程序调用以创建对应的具体产品的对象。 
       3)抽象产品角色：它是具体产品继承的父类或者是实现的接口。在java中一般有抽象类或者接口来实现。 
       4)具体产品角色：具体工厂角色所创建的对象就是此角色的实例。在java中由具体的类来实现。 
       工厂方法模式使用继承自抽象工厂角色的多个子类来代替简单工厂模式中的“上帝类”。正如上面所说，这样便分担了对象承受的压力；而且这样使得结构变得灵活 起来――当有新的产品产生时，只要按照抽象产品角色、抽象工厂角色提供的合同来生成，那么就可以被客户使用，而不必去修改任何已有 的代码。可以看出工厂角色的结构也是符合开闭原则的！ 

代码如下： 

产品类：
[java] view plain copy
print?

    abstract class BMW {  
        public BMW(){  
              
        }  
    }  
    public class BMW320 extends BMW {  
        public BMW320() {  
            System.out.println("制造-->BMW320");  
        }  
    }  
    public class BMW523 extends BMW{  
        public BMW523(){  
            System.out.println("制造-->BMW523");  
        }  
    }  


创建工厂类：
[java] view plain copy
print?

    interface FactoryBMW {  
        BMW createBMW();  
    }  
      
    public class FactoryBMW320 implements FactoryBMW{  
      
        @Override  
        public BMW320 createBMW() {  
      
            return new BMW320();  
        }  
      
    }  
    public class FactoryBMW523 implements FactoryBMW {  
        @Override  
        public BMW523 createBMW() {  
      
            return new BMW523();  
        }  
    }  


客户类：
[java] view plain copy
print?

    public class Customer {  
        public static void main(String[] args) {  
            FactoryBMW320 factoryBMW320 = new FactoryBMW320();  
            BMW320 bmw320 = factoryBMW320.createBMW();  
      
            FactoryBMW523 factoryBMW523 = new FactoryBMW523();  
            BMW523 bmw523 = factoryBMW523.createBMW();  
        }  
    }  


 工厂方法模式仿佛已经很完美的对对象的创建进行了包装，使得客户程序中仅仅处理抽象产品角色提供的接口，但使得对象的数量成倍增长。当产品种类非常多时，会出现大量的与之对应的工厂对象，这不是我们所希望的。

参考http://blog.csdn.NET/hguisu/article/details/7505909


以上就是简单工厂模式，工厂方法模式，抽象工厂模式在这里。

 

作者：jason0539

微博：http://weibo.com/2553717707

==================

Java设计模式三：建造者模式(Builder Pattern)
Posted on 2012-11-30 17:17 IT随笔 阅读(629) 评论(0) 编辑 收藏
建造者模式也叫做生成器模式，将一个复杂的对象的构造与它的表示分离，使同样的构建过程可以创建不同的表示。

角色：
1. builder抽象建造者: 为创建一个产品对象的各个部件指定抽象接口.

2. ConcreteBuilder具体建造者: 实现Builder的接口以构造和装配该产品的各个部件,定义并明确它所创建的表示,并提供一个检索产品的接口.

3. Director导演:负责安排已有模块的顺序，然后告诉Builder开始建造.

4. Product产品类: 表示被构造的复杂对象.通常实现了模板方法模式.

 

类图:

 

实例:
//Builder
public interface PersonBuilder {
　　void buildHead();
　　void buildBody();
　　void buildFoot();
　　Person buildPerson();
}

//ConcreteBuilder
public class ManBuilder implements PersonBuilder {
　　Person person;
　　public ManBuilder() {
　　person = new Man();
　　}
　　public void buildbody() {
　　person.setBody("建造男人的身体");
　　}
　　public void buildFoot() {
　　person.setFoot("建造男人的脚");
　　}
　　public void buildHead() {
　　person.setHead("建造男人的头");
　　}
　　public Person buildPerson() {
　　return person;
　　}
}

//Dirictor
public class PersonDirector {
　　public Person constructPerson(PersonBuilder pb) {
　　pb.buildHead();
　　pb.buildBody();
　　pb.buildFoot();
　　return pb.buildPerson();
　　}
　　}

//Product
public class Person {
　　private String head;
　　private String body;
　　private String foot;
　　public String getHead() {
　　return head;
　　}
　　public void setHead(String head) {
　　this.head = head;
　　}
　　public String getBody() {
　　return body;
　　}
　　public void setBody(String body) {
　　this.body = body;
　　}
　　public String getFoot() {
　　return foot;
　　}
　　public void setFoot(String foot) {
　　this.foot = foot;
　　}
}

public class Man extends Person {
}

//Test
public class Test{
　　public static void main(String[] args) {
　　PersonDirector pd = new PersonDirector();
　　Person person = pd.constructPerson(new ManBuilder());
　　System.out.println(person.getBody());
　　System.out.println(person.getFoot());
　　System.out.println(person.getHead());
　　}
}



==================


 Builder模式在Java中的应用

 http://www.cnblogs.com/moonz-wu/archive/2011/01/11/1932473.html

在设计模式中对Builder模式的定义是用于构建复杂对象的一种模式，所构建的对象往往需要多步初始化或赋值才能完成。那么，在实际的开发过程中，我们哪些地方适合用到Builder模式呢？其中使用Builder模式来替代多参数构造函数是一个比较好的实践法则。

我们常常会面临编写一个这样的实现类(假设类名叫DoDoContact)，这个类拥有多个构造函数，

DoDoContact(String name);

DoDoContact(String name, int age);

DoDoContact(String name, int age, String address);

DoDoContact(String name, int age, String address, int cardID);

这样一系列的构造函数主要目的就是为了提供更多的客户调用选择，以处理不同的构造请求。这种方法很常见，也很有效力，但是它的缺点也很多。类的作者不得不书写多种参数组合的构造函数，而且其中还需要设置默认参数值，这是一个需要细心而又枯燥的工作。其次，这样的构造函数灵活性也不高，而且在调用时你不得不提供一些没有意义的参数值，例如，DoDoContact("Ace", -1, "SH")，显然年龄为负数没有意义，但是你又不的不这样做，得以符合Java的规范。如果这样的代码发布后，后面的维护者就会很头痛，因为他根本不知道这个-1是什么含义。对于这样的情况，就非常适合使用Builder模式。Builder模式的要点就是通过一个代理来完成对象的构建过程。这个代理职责就是完成构建的各个步骤，同时它也是易扩展的。下面是改写自Effective Java里面的一段代码：
	
public class DoDoContact {
    private final int    age;
    private final int    safeID;
    private final String name;
    private final String address;
 
    public int getAge() {
        return age;
    }
 
    public int getSafeID() {
        return safeID;
    }
 
    public String getName() {
        return name;
    }
 
    public String getAddress() {
        return address;
    }
 
    public static class Builder {
        private int    age     = 0;
        private int    safeID  = 0;
        private String name    = null;
        private String address = null;

	
　　　// 构建的步骤
        public Builder(String name) {
            this.name = name;
        }
 
        public Builder age(int val) {
            age = val;
            return this;
        }
 
        public Builder safeID(int val) {
            safeID = val;
            return this;
        }
 
        public Builder address(String val) {
            address = val;
            return this;
        }
 
        public DoDoContact build() { // 构建，返回一个新对象
            return new DoDoContact(this);
        }
    }
 
    private DoDoContact(Builder b) {
        age = b.age;
        safeID = b.safeID;
        name = b.name;
        address = b.address;
 
    }
}

最终，客户程序可以很灵活的去构建这个对象。
	
DoDoContact ddc = new DoDoContact.Builder("Ace").age(10)
                .address("beijing").build();
System.out.println("name=" + ddc.getName() + "age =" + ddc.getAge()
                + "address" + ddc.getAddress());
将想法付诸于实践，借此来影响他人是一个人存在的真正价值

===================

http://www.cnblogs.com/itTeacher/archive/2012/12/02/2797857.html

Java设计模式四: 原型模式(Prototype Pattern)
Posted on 2012-12-02 00:27 IT随笔 阅读(17496) 评论(0) 编辑 收藏

原型模式是一种创建型设计模式,它通过复制一个已经存在的实例来返回新的实例,而不是新建实例.被复制的实例就是我们所称的原型,这个原型是可定制的.
原型模式多用于创建复杂的或者耗时的实例, 因为这种情况下,复制一个已经存在的实例可以使程序运行更高效,或者创建值相等,只是命名不一样的同类数据.

原型模式中的拷贝分为"浅拷贝"和"深拷贝":
浅拷贝: 对值类型的成员变量进行值的复制,对引用类型的成员变量只复制引用,不复制引用的对象.
深拷贝: 对值类型的成员变量进行值的复制,对引用类型的成员变量也进行引用对象的复制.

类图:

实例一:浅拷贝
public class Prototype implements Cloneable {
 private String name;

 public String getName() {
  return name;
 }

 public void setName(String name) {
  this.name = name;
 }

 public Object clone() {
  try {
   return super.clone();
  } catch (CloneNotSupportedException e) {   
   e.printStackTrace();
   return null;
  }
 } 
 
}

public class TestMain {

 public static void main(String[] args) {
  testPrototype();
 }
 
 private static void testPrototype(){
  Prototype pro = new Prototype();
  pro.setName("original object");
  Prototype pro1 = (Prototype)pro.clone();
  pro.setName("changed object1");
  
  System.out.println("original object:" + pro.getName());
  System.out.println("cloned object:" + pro1.getName());
  
 }

}
结果:
original object:changed object1
cloned object:original object


实例二: 浅拷贝
public class Prototype{
 private String name;

 public String getName() {
  return name;
 }

 public void setName(String name) {
  this.name = name;
 } 
 
}
public class NewPrototype implements Cloneable {
 
 private String id;
 
 public String getId() {
  return id;
 }

 public void setId(String id) {
  this.id = id;
 }

 private Prototype prototype;
 
 public Prototype getPrototype() {
  return prototype;
 }

 public void setPrototype(Prototype prototype) {
  this.prototype = prototype;
 }


 public Object clone(){ 
  try {
   return super.clone();
  } catch (CloneNotSupportedException e) {
   e.printStackTrace();
   return null;
  }  
 }

}
public class TestMain {

 public static void main(String[] args) {
  // TODO Auto-generated method stub
  testPrototype();
 }
 
 private static void testPrototype(){
  Prototype pro = new Prototype();
  pro.setName("original object");
  NewPrototype newObj = new NewPrototype();
  newObj.setId("test1");
  newObj.setPrototype(pro);
  
  NewPrototype copyObj = (NewPrototype)newObj.clone();
  copyObj.setId("testCopy");
  copyObj.getPrototype().setName("changed object");
  
  System.out.println("original object id:" + newObj.getId());
  System.out.println("original object name:" + newObj.getPrototype().getName());
  
  System.out.println("cloned object id:" + copyObj.getId());
  System.out.println("cloned object name:" + copyObj.getPrototype().getName());
  
 }

}

结果:
original object id:test1
original object name:changed object
cloned object id:testCopy
cloned object name:changed object


实例三: 深拷贝
public class Prototype implements Cloneable {
 private String name;

 public String getName() {
  return name;
 }

 public void setName(String name) {
  this.name = name;
 }

 public Object clone() {
  try { 
   return super.clone();
  } catch (CloneNotSupportedException e) {   
   e.printStackTrace();
   return null;
  }
 } 
 
}

public class NewPrototype implements Cloneable {
 
 private String id;
 
 public String getId() {
  return id;
 }

 public void setId(String id) {
  this.id = id;
 }

 private Prototype prototype;
 
 public Prototype getPrototype() {
  return prototype;
 }

 public void setPrototype(Prototype prototype) {
  this.prototype = prototype;
 }


 public Object clone(){
  NewPrototype ret = null;
  try {
   ret = (NewPrototype)super.clone();
   ret.prototype = (Prototype)this.prototype.clone();
   return ret;
  } catch (CloneNotSupportedException e) {
   e.printStackTrace();
   return null;
  }  
 }

}

public class TestMain {

 /**
  * @param args
  */
 public static void main(String[] args) {
  testDeepCopy();
 }
 
 private static void testDeepCopy(){
  Prototype pro = new Prototype();
  pro.setName("original object");
  NewPrototype newObj = new NewPrototype();
  newObj.setId("test1");
  newObj.setPrototype(pro);
  
  NewPrototype copyObj = (NewPrototype)newObj.clone();
  copyObj.setId("testCopy");
  copyObj.getPrototype().setName("changed object");
  
  System.out.println("original object id:" + newObj.getId());
  System.out.println("original object name:" + newObj.getPrototype().getName());
  
  System.out.println("cloned object id:" + copyObj.getId());
  System.out.println("cloned object name:" + copyObj.getPrototype().getName());
  
 }

}

结果:
original object id:test1
original object name:original object
cloned object id:testCopy
cloned object name:changed object

实例四: 利用串行化来做深复制
把对象写道流里的过程是串行化(Serilization)过程;把对象从流中读出来是并行化(Deserialization)过程. 写在流里的是对象的一个拷贝,然后再从流里读出来重建对象.
public class PrototypeSe implements Serializable {

 private String name;

 public String getName() {
  return name;
 }

 public void setName(String name) {
  this.name = name;
 }

}

public class NewPrototypeSe implements Serializable {
 
 private String id;
 
 public String getId() {
  return id;
 }

 public void setId(String id) {
  this.id = id;
 }

 private PrototypeSe prototype;
 
 public PrototypeSe getPrototype() {
  return prototype;
 }

 public void setPrototype(PrototypeSe prototype) {
  this.prototype = prototype;
 }
 
 public Object deepClone(){
  try {
   ByteArrayOutputStream bo = new ByteArrayOutputStream();
   ObjectOutputStream oo = new ObjectOutputStream(bo);   
   oo.writeObject(this);   
   
   ByteArrayInputStream bi = new ByteArrayInputStream(bo.toByteArray());
   ObjectInputStream oi = new ObjectInputStream(bi);
   return oi.readObject(); 
  } catch (IOException | ClassNotFoundException e) {
   // TODO Auto-generated catch block
   e.printStackTrace();
   return null;
  }
 }

}

public class TestDeepClone {

 public static void main(String[] args) {
  // TODO Auto-generated method stub
  PrototypeSe po = new PrototypeSe();
  po.setName("test1");
  NewPrototypeSe se = new NewPrototypeSe();
  se.setPrototype(po);
  
  NewPrototypeSe deepClone = (NewPrototypeSe)se.deepClone();
  deepClone.getPrototype().setName("test2");
  
  System.out.println("original name:" + se.getPrototype().getName());
  System.out.println("cloned name:" + deepClone.getPrototype().getName());

 }
}
结果:
original name:test1
cloned name:test2

================



